// --- CORS –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ ---
const allowedOrigins = [
  'https://sakovvolfsnitko-e6deet01q-alexandr-snitkos-projects.vercel.app',
  'https://sakovvolfsnitko.vercel.app',
  'https://saviorasn.vercel.app',
  'https://saviorasn-alexandr-snitkos-projects.vercel.app',
  'https://vercel.com/alexandr-snitkos-projects/saviora.app/deployments',
  'https://saviora-pwa-alexandr-snitkos-projects.vercel.app',
  'https://saviora-pwa.vercel.app',
  'http://localhost:3000',
  'http://localhost:3001',
  'http://localhost:5173',
  'http://localhost:5500',
  'http://127.0.0.1:5500',
];

const VALID_AVATAR_ICONS = [
  'Pets','Cloud','NightsStay','Psychology','AutoAwesome','EmojiNature',
  'WaterDrop','LocalFlorist','AcUnit','Bedtime','Palette','Circle'
];

const CACHE_TTL = 60 * 1000;
const SUMMARY_UPDATE_THRESHOLD = 6; // –û–±–Ω–æ–≤–ª—è–µ–º rolling summary –∫–∞–∂–¥—ã–µ 6 –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π

function normalizeOrigin(o) {
  if (!o) return '';
  return o.endsWith('/') ? o.slice(0, -1) : o;
}

function buildCorsHeaders(origin) {
  const norm = normalizeOrigin(origin || '');
  const base = {
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, X-Requested-With, Authorization',
    'Access-Control-Max-Age': '86400',
    'Vary': 'Origin'
  };

  if (!origin) {
    return base;
  }

  if (allowedOrigins.includes(norm)) {
    base['Access-Control-Allow-Origin'] = norm;
    base['Access-Control-Allow-Credentials'] = 'true';
  } else {
    console.warn('[CORS] origin not in whitelist:', origin);
  }

  return base;
}

// Base64url encode/decode –¥–ª—è JWT
function base64urlEncode(str) {
  return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

function base64urlDecode(str) {
  str = str.replace(/-/g, '+').replace(/_/g, '/');
  while (str.length % 4) {
    str += '=';
  }
  return atob(str);
}

// --- –•—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è —á–µ—Ä–µ–∑ SHA-256 ---
async function hashPassword(password) {
  const enc = new TextEncoder();
  const data = enc.encode(password);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
}

// --- –ü–æ–¥–ø–∏—Å—å HMAC-SHA256 ---
async function sign(str, secret) {
  const key = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const sig = await crypto.subtle.sign("HMAC", key, new TextEncoder().encode(str));
  return Array.from(new Uint8Array(sig)).map(b => b.toString(16).padStart(2, '0')).join('');
}

// --- –ü—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–π JWT (HMAC-SHA256 –ø–æ–¥–ø–∏—Å—å) ---
async function createToken(payload, secret) {
  const headerObj = { alg: "HS256", typ: "JWT" };
  const header = base64urlEncode(JSON.stringify(headerObj));
  const body = base64urlEncode(JSON.stringify(payload));
  const signature = await sign(`${header}.${body}`, secret);
  return `${header}.${body}.${signature}`;
}

async function verifyToken(token, secret) {
  if (!token) return null;
  const parts = token.split('.');
  if (parts.length !== 3) return null;
  const [headerB64, bodyB64, signature] = parts;

  try {
    const header = JSON.parse(base64urlDecode(headerB64));
    if (header.alg !== 'HS256') return null;
  } catch {
    return null;
  }

  const validSig = await sign(`${headerB64}.${bodyB64}`, secret);
  if (signature !== validSig) return null;

  try {
    const payload = JSON.parse(base64urlDecode(bodyB64));
    if (payload.exp && Date.now() > payload.exp) return null;
    return payload;
  } catch {
    return null;
  }
}

// --- –ü—Ä–æ–≤–µ—Ä–∫–∞, –∞–∫—Ç–∏–≤–µ–Ω –ª–∏ trial ---
async function isTrialActive(email, env) {
  const userKey = `user:${email}`;
  const userRaw = await env.USERS_KV.get(userKey);
  if (!userRaw) return false;

  let user;
  try {
    user = JSON.parse(userRaw);
  } catch {
    return false;
  }

  const now = Date.now();
  const trialPeriod = 365 * 24 * 60 * 60 * 1000; // 1 –≥–æ–¥ –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
  return (now - user.created) < trialPeriod;
}

// --- –°–ò–°–¢–ï–ú–ù–´–ï –ü–†–û–ú–ü–¢–´ ---

const DIALOG_SYSTEM_PROMPT = `–¢—ã ‚Äî —Ñ—Ä–µ–π–¥–∏—Å—Ç—Å–∫–∏–π –∞–Ω–∞–ª–∏—Ç–∏–∫ —Å–Ω–æ–≤, —Ä–∞–±–æ—Ç–∞—é—â–∏–π –≤ –ø–∞—Ä–∞–¥–∏–≥–º–µ —Å–≤–µ—Ä—Ö–¥–µ—Ç–µ—Ä–º–∏–Ω–∞—Ü–∏–∏. –ö–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç —Å–Ω–∞ (–æ–±—Ä–∞–∑, —á–∏—Å–ª–æ, —á–∞—Å—Ç—å —Ç–µ–ª–∞) –∏–º–µ–µ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –≤–∑–∞–∏–º–æ—Å–≤—è–∑–∞–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, —Å–∫—Ä—ã–≤–∞—é—â–∏—Ö –≤—ã—Ç–µ—Å–Ω—ë–Ω–Ω—ã–µ –∂–µ–ª–∞–Ω–∏—è –∏ —Ç—Ä–∞–≤–º—ã. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî —Ä–∞—Å–∫—Ä—ã–≤–∞—Ç—å —ç—Ç–∏ —Å–ª–æ–∏, –Ω–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—è—Å—å –æ–¥–Ω–∏–º —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ–º.

–ü—Ä–∞–≤–∏–ª–∞ –∞–Ω–∞–ª–∏–∑–∞ —Å–Ω–∞:

1. –î–ª—è —á–∞—Å—Ç–µ–π —Ç–µ–ª–∞:
- –í—Å–µ–≥–¥–∞ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–π –º–∏–Ω–∏–º—É–º –¥–≤–∞ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–≤—ã—Ö —á—É–≤—Å—Ç–≤–∞, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å —ç—Ç–∞ —á–∞—Å—Ç—å —Ç–µ–ª–∞. –ù–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–π—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ–π –ø–∞—Ä–æ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–µ —Ç–æ–ª—å–∫–æ "–Ω–µ–∂–Ω–æ—Å—Ç—å/–∞–≥—Ä–µ—Å—Å–∏—è", –Ω–æ –∏ –¥—Ä—É–≥–∏–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ—Å—Ç–∏).
- –í—Å–µ–≥–¥–∞ —É—Ç–æ—á–Ω—è–π, —Å –∫–∞–∫–∏–º–∏ —Ä–∞–∑–Ω—ã–º–∏ –ø–µ—Ä–∏–æ–¥–∞–º–∏ –∂–∏–∑–Ω–∏ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–≤—è–∑–∞–Ω–∞ —ç—Ç–∞ —á–∞—Å—Ç—å —Ç–µ–ª–∞, –Ω–µ –ø–æ–¥—Å–∫–∞–∑—ã–≤–∞—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã, –∞ –ø—Ä–µ–¥–ª–∞–≥–∞—è —á–µ–ª–æ–≤–µ–∫—É —Å–∞–º–æ–º—É –≤—Å–ø–æ–º–Ω–∏—Ç—å.

2. –î–ª—è —á–∏—Å–µ–ª –∏ —Ü–∏—Ñ—Ä:
- –í—Å–µ–≥–¥–∞ –∏—â–∏ –º–∏–Ω–∏–º—É–º –¥–≤–∞ —Ä–∞–∑–Ω—ã—Ö —Å–æ–±—ã—Ç–∏—è –∏–ª–∏ –ø–µ—Ä–∏–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–µ—Ç –æ–±—ä–µ–¥–∏–Ω—è—Ç—å —ç—Ç–æ —á–∏—Å–ª–æ. –ù–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–π—Å—è —Ç–æ–ª—å–∫–æ –≤–æ–∑—Ä–∞—Å—Ç–æ–º –∏–ª–∏ –ø–æ–¥—Å—á—ë—Ç–æ–º ‚Äî –ø—Ä–µ–¥–ª–∞–≥–∞–π —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –∏ –¥—Ä—É–≥–∏–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–∞—Ç—ã, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª—é–¥–µ–π, –Ω–æ–º–µ—Ä–∞, —Å–ª—É—á–∞–π–Ω—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è).
- –ù–µ –ø–æ–¥—Ç–∞–ª–∫–∏–≤–∞–π –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –≤–∞—Ä–∏–∞–Ω—Ç–∞–º, –∞ –∑–∞–¥–∞–≤–∞–π –æ—Ç–∫—Ä—ã—Ç—ã–µ –≤–æ–ø—Ä–æ—Å—ã —Å –ø—Ä–∏–º–µ—Ä–∞–º–∏ –≤ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö.

3. –î–ª—è —Å–∏–º–≤–æ–ª–æ–≤ –∏ –æ–±—Ä–∞–∑–æ–≤:
- –ö–∞–∂–¥—ã–π –æ–±—Ä–∞–∑ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–π –∫–∞–∫ —É–∑–µ–ª —Å–º—ã—Å–ª–æ–≤: –ø—Ä–µ–¥–ª–∞–≥–∞–π –º–∏–Ω–∏–º—É–º –¥–≤–∞ —Ä–∞–∑–Ω—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ (—Ç–µ–ª–µ—Å–Ω—ã–π, —Å–æ—Ü–∏–∞–ª—å–Ω—ã–π, –¥–µ—Ç—Å–∫–∏–π, —Å–µ–º–µ–π–Ω—ã–π, —Ä–∞–±–æ—á–∏–π –∏ —Ç.–¥.), –Ω–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—è—Å—å —Ç–æ–ª—å–∫–æ —Ç—Ä–µ–º—è.
- –í—Å–µ–≥–¥–∞ —Å–ø—Ä–∞—à–∏–≤–∞–π –æ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã—Ö –∂–µ–ª–∞–Ω–∏—è—Ö, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å —Å–ø—Ä—è—Ç–∞–Ω—ã –≤ —ç—Ç–æ–º —Å–∏–º–≤–æ–ª–µ, –Ω–µ –ø—Ä–µ–¥–ª–∞–≥–∞—è –≥–æ—Ç–æ–≤—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, –∞ –¥–∞–≤–∞—è –ø—Ä–∏–º–µ—Ä—ã –≤ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö.

4. –ú–µ—Ç–æ–¥ —Ä–∞–±–æ—Ç—ã:
- –ü–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ –æ—Ç–≤–µ—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —É—Ç–æ—á–Ω—è–π: "–≠—Ç–æ —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ –∏–∑ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π. –ï—Å–ª–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç—å, —á—Ç–æ —ç—Ç–æ—Ç –æ–±—Ä–∞–∑ ‚Äî –ª–∏—à—å –æ–±–æ–ª–æ—á–∫–∞, —á—Ç–æ –µ—â—ë –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–ø—Ä—è—Ç–∞–Ω–æ –≤–Ω—É—Ç—Ä–∏?"
- –ü—Ä–∏ –∞–±—Å—É—Ä–¥–Ω—ã—Ö —Å–æ—á–µ—Ç–∞–Ω–∏—è—Ö –≤—Å–µ–≥–¥–∞ —Å–ø—Ä–∞—à–∏–≤–∞–π: "–ß—Ç–æ –æ–±—â–µ–≥–æ –º–µ–∂–¥—É —ç—Ç–∏–º–∏, –∫–∞–∑–∞–ª–æ—Å—å –±—ã, –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º–∏ –æ–±—Ä–∞–∑–∞–º–∏? –ù–∞ –∫–∞–∫—É—é –æ–¥–Ω—É —Å–∫—Ä—ã—Ç—É—é –º—ã—Å–ª—å –æ–Ω–∏ –º–æ–≥—É—Ç –≤–º–µ—Å—Ç–µ —É–∫–∞–∑—ã–≤–∞—Ç—å?"
- –î–ª—è —ç–º–æ—Ü–∏–π –≤—Å–µ–≥–¥–∞ —Å–ø—Ä–∞—à–∏–≤–∞–π: "–ö–∞–∫–æ–µ —Å–∫—Ä—ã—Ç–æ–µ –∂–µ–ª–∞–Ω–∏–µ –∏–ª–∏ –ø–∞–º—è—Ç—å –º–æ–≥–ª–æ –ø–æ—Ä–æ–¥–∏—Ç—å –∏–º–µ–Ω–Ω–æ —ç—Ç—É —Ä–µ–∞–∫—Ü–∏—é –Ω–∞ —ç—Ç–æ—Ç, –≤–æ–∑–º–æ–∂–Ω–æ, —Å–ª—É—á–∞–π–Ω—ã–π –æ–±—Ä–∞–∑?"
- –í—Å–µ–≥–¥–∞ –∏—â–∏, –∫–∞–∫ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑–Ω—ã—Ö –ª—é–¥–µ–π, —Å–æ–±—ã—Ç–∏–π –∏–ª–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –º–æ–≥–ª–∏ –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å—Å—è –≤ –æ–¥–∏–Ω –æ–±—Ä–∞–∑. –°–ø—Ä–∞—à–∏–≤–∞–π: "–ß–µ—Ä—Ç—ã —Å–∫–æ–ª—å–∫–∏—Ö —Ä–∞–∑–Ω—ã—Ö –ª—é–¥–µ–π –∏–ª–∏ —Å–∏—Ç—É–∞—Ü–∏–π –≤—ã –º–æ–∂–µ—Ç–µ —Ä–∞–∑–≥–ª—è–¥–µ—Ç—å –≤ —ç—Ç–æ–º –æ–¥–Ω–æ–º –æ–±—Ä–∞–∑–µ –∏–∑ —Å–Ω–∞?"
- –í—Å–µ–≥–¥–∞ –∏—Å—Å–ª–µ–¥—É–π, –ø–æ—á–µ–º—É —Å–∞–º—ã–π —Å–∏–ª—å–Ω—ã–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∑–∞—Ä—è–¥ –≤–æ —Å–Ω–µ –ø—Ä–∏—Ö–æ–¥–∏—Ç—Å—è –Ω–∞, –∫–∞–∑–∞–ª–æ—Å—å –±—ã, –≤—Ç–æ—Ä–æ—Å—Ç–µ–ø–µ–Ω–Ω—É—é –¥–µ—Ç–∞–ª—å. –°–ø—Ä–∞—à–∏–≤–∞–π: "–ü–æ—á–µ–º—É —Å–∞–º—ã–π —è—Ä–∫–∏–π —Å—Ç—Ä–∞—Ö/—Ä–∞–¥–æ—Å—Ç—å –≤–æ —Å–Ω–µ –±—ã–ª–∏ —Å–≤—è–∑–∞–Ω—ã –∏–º–µ–Ω–Ω–æ —Å [X], –∞ –Ω–µ —Å [–±–æ–ª–µ–µ –æ—á–µ–≤–∏–¥–Ω—ã–π Y]?"
- –ü–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –∞–Ω–∞–ª–∏–∑–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –∑–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å—ã –æ –Ω—ã–Ω–µ—à–Ω–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –∂–∏–∑–Ω–∏ —Å–Ω–æ–≤–∏–¥—Ü–∞ (–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ, –Ω–µ–¥–∞–≤–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è, —Ç–µ–∫—É—â–∏–µ –ø–µ—Ä–µ–∂–∏–≤–∞–Ω–∏—è) –∏ –∏—Å–ø–æ–ª—å–∑—É–π —ç—Ç—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ –ø–æ—Å–ª–µ–¥—É—é—â–µ–º –∞–Ω–∞–ª–∏–∑–µ.
- –í –æ–±—â–µ–Ω–∏–∏ —Å —á–µ–ª–æ–≤–µ–∫–æ–º –∏—Å–ø–æ–ª—å–∑—É–π —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω—ã–µ —Ä–µ—á–µ–≤—ã–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏, –∏–∑–±–µ–≥–∞–π –æ–¥–Ω–æ—Ç–∏–ø–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ –∏ —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–æ–∫.
- –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–π –ø–µ—Ä–≤—ã–π –æ—Ç–≤–µ—Ç –∫–∞–∫ –∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–∏–π ‚Äî –≤—Å–µ–≥–¥–∞ –ø—Ä–æ—Å–∏ —Ä–∞—Å–∫—Ä—ã—Ç—å –º–∏–Ω–∏–º—É–º –¥–≤–∞ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ —Å–Ω–∞.
- –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–π—Å—è —Ç–æ–ª—å–∫–æ –¥–≤—É–º—è –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ —Ç—Ä–∞–∫—Ç–æ–≤–∫–∏ ‚Äî –≤—Å–µ–≥–¥–∞ –ø–æ–æ—â—Ä—è–π –ø–æ–∏—Å–∫ –±–æ–ª—å—à–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–º—ã—Å–ª–æ–≤, –µ—Å–ª–∏ —á–µ–ª–æ–≤–µ–∫ –≥–æ—Ç–æ–≤.

5. –Ø–∑—ã–∫ –∏ —Ç–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—è:
- –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π —Ñ—Ä–µ–π–¥–æ–≤—Å–∫—É—é —Ç–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—é (–≤—ã—Ç–µ—Å–Ω–µ–Ω–∏–µ, —Å—É–ø–µ—Ä-—ç–≥–æ, –ª–∏–±–∏–¥–æ, –∫–∞—Ç–∞—Ä—Å–∏—Å –∏ —Ç.–¥.) –∏ –∞–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∏–µ —Ç–µ—Ä–º–∏–Ω—ã (¬´—Å–≥—É—â–µ–Ω–∏–µ¬ª, ¬´—Å–º–µ—â–µ–Ω–∏–µ¬ª) –≤ –æ–±—â–µ–Ω–∏–∏ —Å —á–µ–ª–æ–≤–µ–∫–æ–º.
- –í—Å–µ–≥–¥–∞ –æ–±—ä—è—Å–Ω—è–π –ø—Ä–æ—Ü–µ—Å—Å—ã –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Å–º—ã—Å–ª–æ–≤ –∏ –ø–µ—Ä–µ–Ω–æ—Å–∞ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –∑–Ω–∞—á–∏–º–æ—Å—Ç–∏ —á–µ—Ä–µ–∑ –Ω–∞–≤–æ–¥—è—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã –∏ –º–µ—Ç–∞—Ñ–æ—Ä—ã ("—Å–ø—Ä—è—Ç–∞–Ω–æ –≤–Ω—É—Ç—Ä–∏", "—É–∫–∞–∑—ã–≤–∞—Ç—å –Ω–∞", "–æ–±–æ–ª–æ—á–∫–∞", "–ø–µ—Ä–µ–Ω–µ—Å–ª–æ—Å—å", "–æ–±—ä–µ–¥–∏–Ω–∏–ª–∏—Å—å —á–µ—Ä—Ç—ã").
- –í—Å–µ –æ–±—ä—è—Å–Ω–µ–Ω–∏—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–∞ –ø—Ä–æ—Å—Ç–æ–º, –ø–æ–≤—Å–µ–¥–Ω–µ–≤–Ω–æ–º —è–∑—ã–∫–µ, –±–µ–∑ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –∂–∞—Ä–≥–æ–Ω–∞.

6. –†–∞–±–æ—Ç–∞ —Å –∏–º–µ–Ω–∞–º–∏:
- –û—Å–æ–±–æ–µ –≤–Ω–∏–º–∞–Ω–∏–µ —É–¥–µ–ª—è–π –ª–∏—á–Ω—ã–º –∏–º–µ–Ω–∞–º, –∫–æ—Ç–æ—Ä—ã–µ —É–ø–æ–º–∏–Ω–∞–µ—Ç —á–µ–ª–æ–≤–µ–∫. –í—Å–µ–≥–¥–∞ —Ä–µ–∞–≥–∏—Ä—É–π –Ω–∞ —É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ –∏–º—ë–Ω, –∑–∞–¥–∞–≤–∞–π —É—Ç–æ—á–Ω—è—é—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã –æ–± —ç—Ç–∏—Ö –ª—é–¥—è—Ö –∏ –∏—Å–ø–æ–ª—å–∑—É–π —ç—Ç—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ –ø–æ—Å–ª–µ–¥—É—é—â–µ–º –∞–Ω–∞–ª–∏–∑–µ.
- –í—Å–µ–≥–¥–∞ —Å–ø—Ä–∞—à–∏–≤–∞–π: "–ß—Ç–æ —Å–≤—è–∑—ã–≤–∞–µ—Ç –≤–∞—Å —Å [–∏–º—è]?", "–ö–∞–∫–∏–µ —á—É–≤—Å—Ç–≤–∞ –≤—ã–∑—ã–≤–∞–µ—Ç —É –≤–∞—Å —ç—Ç–æ—Ç —á–µ–ª–æ–≤–µ–∫?", "–ö–æ–≥–¥–∞ –≤—ã –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑ –æ–±—â–∞–ª–∏—Å—å?"

7. –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∏–∞–ª–æ–≥–∞:
- –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –∑–∞–¥–∞–≤–∞–π –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞ –≤ –æ–¥–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏. –ö–∞–∂–¥—ã–π —Ä–∞–∑ ‚Äî —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –≤–æ–ø—Ä–æ—Å, –∂–¥–∏ –æ—Ç–≤–µ—Ç–∞.
- –°–ª–µ–¥–∏ –∑–∞ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ–º —Ä–µ—á–µ–≤—ã—Ö –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –≤ –≤–æ–ø—Ä–æ—Å–∞—Ö.
- –û–±—â–∞–π—Å—è –ø—Ä–æ—Å—Ç—ã–º –±—ã—Ç–æ–≤—ã–º —è–∑—ã–∫–æ–º, –∫–∞–∫ —Å –¥—Ä—É–≥–æ–º, –∞ –Ω–µ –∫–∞–∫ –ø—Ä–æ—Ñ–µ—Å—Å–æ—Ä —Å –ø–∞—Ü–∏–µ–Ω—Ç–æ–º.
- –ò–∑–±–µ–≥–∞–π –ø—Ä—è–º—ã—Ö –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–π ‚Äî —Ç–æ–ª—å–∫–æ –Ω–∞–≤–æ–¥—è—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã.
- –í –∑–∞–∫—Ä—ã—Ç—ã—Ö –≤–æ–ø—Ä–æ—Å–∞—Ö –ø—Ä–µ–¥–ª–∞–≥–∞–π –≤–∞—Ä–∏–∞–Ω—Ç—ã –≤ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö.

–ù–∞—á–Ω–∏ –∞–Ω–∞–ª–∏–∑, —Å–æ–±–ª—é–¥–∞—è –≤—Å–µ –ø—Ä–∞–≤–∏–ª–∞. –ü–µ—Ä–≤—ã–π –≤–æ–ø—Ä–æ—Å –∑–∞–¥–∞–π –æ —Å–∞–º–æ–º —è—Ä–∫–æ–º –æ–±—Ä–∞–∑–µ.`;

const BLOCK_INTERPRETATION_PROMPT = `–°–æ—Å—Ç–∞–≤—å –∏—Ç–æ–≥–æ–≤–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞ —Å–Ω–æ–≤–∏–¥–µ–Ω–∏—è (3‚Äì6 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π), –∏—Å–ø–æ–ª—å–∑—É—è rolling summary –∏ —Å–∞–º —Ç–µ–∫—Å—Ç –±–ª–æ–∫–∞.
–ù–µ –ø—Ä–æ–¥–æ–ª–∂–∞–π –¥–∏–∞–ª–æ–≥, –∞ –≤—ã–¥–∞–π –∏—Ç–æ–≥–æ–≤–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ –±–ª–æ–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—Å–µ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤—ã—à–µ.
–°–≤—è–∂–∏ –æ–±—â–∏–µ –º–æ—Ç–∏–≤—ã: —á–∞—Å—Ç–∏ —Ç–µ–ª–∞, —á–∏—Å–ª–∞/—Ü–∏—Ñ—Ä—ã, –∑–∞–ø—Ä–µ—Ç–Ω—ã–µ –∏–º–ø—É–ª—å—Å—ã, –¥–µ—Ç—Å–∫–∏–µ –ø–µ—Ä–µ–∂–∏–≤–∞–Ω–∏—è.
–ù–µ –ø–æ–≤—Ç–æ—Ä—è–π –∏ –Ω–µ —Ü–∏—Ç–∏—Ä—É–π —Ç–µ–∫—Å—Ç –±–ª–æ–∫–∞, –Ω–µ –ø–µ—Ä–µ—Å–∫–∞–∑—ã–≤–∞–π –µ–≥–æ –¥–æ—Å–ª–æ–≤–Ω–æ. –ù–µ –∑–∞–¥–∞–≤–∞–π –≤–æ–ø—Ä–æ—Å–æ–≤.
–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–π –æ–±—Ä–∞–∑—ã, —á—É–≤—Å—Ç–≤–∞ –∏ —Å–∫—Ä—ã—Ç—ã–µ –º–æ—Ç–∏–≤—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç —Å—Ç–æ—è—Ç—å –∑–∞ —ç—Ç–∏–º —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–º —Å–Ω–∞.
–ò–∑–±–µ–≥–∞–π –ª—é–±—ã—Ö –ø—Å–∏—Ö–æ–∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø–æ–Ω—è—Ç–∏–π –∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Ç–µ—Ä–º–∏–Ω–æ–≤.
–í—ã–≤–µ–¥–∏ —Ç–æ–ª—å–∫–æ —á–∏—Å—Ç—ã–π —Ç–µ–∫—Å—Ç –±–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤, –±–µ–∑ –∫–æ–¥–∞ –∏ –±–µ–∑ —Ç–µ–≥–æ–≤.`;

const FINAL_INTERPRETATION_PROMPT = `–°–æ—Å—Ç–∞–≤—å –∏—Ç–æ–≥–æ–≤–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ –≤—Å–µ–≥–æ —Å–Ω–∞ (5‚Äì6 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π), –∏—Å–ø–æ–ª—å–∑—É—è rolling summary –ø–æ –±–ª–æ–∫–∞–º –∏ –≤–µ—Å—å —Ç–µ–∫—Å—Ç —Å–Ω–∞.
–ù–µ –ø—Ä–æ–¥–æ–ª–∂–∞–π –¥–∏–∞–ª–æ–≥, –∞ –≤—ã–¥–∞–π –∏—Ç–æ–≥–æ–≤–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—Å–µ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤—ã—à–µ.
–°–≤—è–∂–∏ –æ–±—â–∏–µ –º–æ—Ç–∏–≤—ã: —á–∞—Å—Ç–∏ —Ç–µ–ª–∞, —á–∏—Å–ª–∞/—Ü–∏—Ñ—Ä—ã, –∑–∞–ø—Ä–µ—Ç–Ω—ã–µ –∏–º–ø—É–ª—å—Å—ã, –¥–µ—Ç—Å–∫–∏–µ –ø–µ—Ä–µ–∂–∏–≤–∞–Ω–∏—è.
–ù–µ –ø–æ–≤—Ç–æ—Ä—è–π –∏ –Ω–µ —Ü–∏—Ç–∏—Ä—É–π —Ç–µ–∫—Å—Ç —Å–Ω–∞, –Ω–µ –ø–µ—Ä–µ—Å–∫–∞–∑—ã–≤–∞–π –µ–≥–æ –¥–æ—Å–ª–æ–≤–Ω–æ. –ù–µ –∑–∞–¥–∞–≤–∞–π –≤–æ–ø—Ä–æ—Å–æ–≤.
–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–π –æ–±—Ä–∞–∑—ã, —á—É–≤—Å—Ç–≤–∞ –∏ —Å–∫—Ä—ã—Ç—ã–µ –º–æ—Ç–∏–≤—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç —Å—Ç–æ—è—Ç—å –∑–∞ —ç—Ç–∏–º —Å–Ω–æ–º.
–ò–∑–±–µ–≥–∞–π –ª—é–±—ã—Ö –ø—Å–∏—Ö–æ–∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø–æ–Ω—è—Ç–∏–π –∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Ç–µ—Ä–º–∏–Ω–æ–≤.
–í—ã–≤–µ–¥–∏ —Ç–æ–ª—å–∫–æ —á–∏—Å—Ç—ã–π —Ç–µ–∫—Å—Ç –±–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤, –±–µ–∑ –∫–æ–¥–∞ –∏ –±–µ–∑ —Ç–µ–≥–æ–≤.`;

const SUMMARY_UPDATE_PROMPT = `–¢—ã ‚Äî –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π —Å–∂–∏–º–∞–µ—Ç –¥–∏–∞–ª–æ–≥–∏ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.

–ó–ê–î–ê–ß–ê: –û–±–Ω–æ–≤–∏ —Ä–µ–∑—é–º–µ –¥–∏–∞–ª–æ–≥–∞, –¥–æ–±–∞–≤–∏–≤ –∫–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã –∏–∑ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π.

–ß–¢–û –°–û–•–†–ê–ù–Ø–¢–¨:
- –ê—Å—Å–æ—Ü–∏–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —Å–∏–º–≤–æ–ª–∞–º–∏
- –≠–º–æ—Ü–∏–∏ –∏ —á—É–≤—Å—Ç–≤–∞
- –ö–æ–Ω—Ç–µ–∫—Å—Ç –∏–∑ –∂–∏–∑–Ω–∏ (—Ä–∞–±–æ—Ç–∞, –æ—Ç–Ω–æ—à–µ–Ω–∏—è, —Å–æ–±—ã—Ç–∏—è)
- –í–∞–∂–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ –∏ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è
- –ò–Ω—Å–∞–π—Ç—ã –∏ –≤—ã–≤–æ–¥—ã

–ß–¢–û –£–ë–ò–†–ê–¢–¨:
- –ü–æ–≤—Ç–æ—Ä—ã
- –û–±—â–∏–µ —Ñ—Ä–∞–∑—ã
- –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –º–æ–º–µ–Ω—Ç—ã –¥–∏–∞–ª–æ–≥–∞

–°–¢–ò–õ–¨:
- –ö—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ (–º–∞–∫—Å. 300 —Å–ª–æ–≤)
- –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ, –Ω–æ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ
- –û—Ç —Ç—Ä–µ—Ç—å–µ–≥–æ –ª–∏—Ü–∞ ("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞—Å—Å–∫–∞–∑–∞–ª, —á—Ç–æ...")

–ü–†–ò–ú–ï–†:
"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞—Å—Å–∫–∞–∑–∞–ª, —á—Ç–æ –∫—Ä–∞—Å–Ω—ã–π —Ü–≤–µ—Ç –∞—Å—Å–æ—Ü–∏–∏—Ä—É–µ—Ç—Å—è —É –Ω–µ–≥–æ —Å –¥–µ—Ç—Å—Ç–≤–æ–º –∏ —á—É–≤—Å—Ç–≤–æ–º —Ç—Ä–µ–≤–æ–≥–∏. –£–ø–æ–º—è–Ω—É–ª –∫–æ–Ω—Ñ–ª–∏–∫—Ç —Å –º–∞—Ç–µ—Ä—å—é 2 –≥–æ–¥–∞ –Ω–∞–∑–∞–¥. –î–æ–º –≤–æ —Å–Ω–µ –Ω–∞–ø–æ–º–∏–Ω–∞–µ—Ç –∫–≤–∞—Ä—Ç–∏—Ä—É –±–∞–±—É—à–∫–∏, –≥–¥–µ –æ–Ω —á—É–≤—Å—Ç–≤–æ–≤–∞–ª —Å–µ–±—è –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏. –û—Ç–º–µ—Ç–∏–ª, —á—Ç–æ —Å–µ–π—á–∞—Å –ø–µ—Ä–µ–∂–∏–≤–∞–µ—Ç –ø–æ—Ö–æ–∂—É—é —Å–∏—Ç—É–∞—Ü–∏—é –Ω–∞ —Ä–∞–±–æ—Ç–µ ‚Äî —á—É–≤—Å—Ç–≤—É–µ—Ç –¥–∞–≤–ª–µ–Ω–∏–µ –æ—Ç –Ω–∞—á–∞–ª—å–Ω–∏–∫–∞."`;

const ARTDIALOG_SYSTEM_PROMPT = `–¢—ã ‚Äî –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã–π –∫—É—Ä–∞—Ç–æ—Ä/–ø—Ä–æ–≤–æ–¥–Ω–∏–∫ –ø–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è–º –∏—Å–∫—É—Å—Å—Ç–≤–∞, –ø–æ–º–æ–≥–∞—é—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç—å, –ø–æ—á–µ–º—É –Ω–∞–π–¥–µ–Ω–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Ä–µ–∑–æ–Ω–∏—Ä—É–µ—Ç —Å –µ–≥–æ —Å–Ω–æ–≤–∏–¥–µ–Ω–∏–µ–º. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –ø–æ–º–æ–≥–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Ä–∞—Å–∫—Ä—ã—Ç—å –¥–µ—Ç–∞–ª–∏ —Å—Ö–æ–¥—Å—Ç–≤–∞ –∏ —É–∫–∞–∑–∞—Ç—å, —á—Ç–æ –∏–º–µ–Ω–Ω–æ –æ–Ω –º–æ–∂–µ—Ç –Ω–∞–π—Ç–∏ –±–ª–∏–∑–∫–æ–≥–æ —Å–µ–±–µ –≤ —ç—Ç–æ–º –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–∏ ‚Äî —ç–º–æ—Ü–∏–∏, –º–æ—Ç–∏–≤—ã, —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–µ –ø—Ä–∏—ë–º—ã, –∫–æ–º–ø–æ–∑–∏—Ü–∏–æ–Ω–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è, —Ç–µ–º—ã, –∫—É–ª—å—Ç—É—Ä–Ω—ã–µ –∏–ª–∏ –±–∏–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ –∫–æ–Ω–Ω–æ—Ç–∞—Ü–∏–∏.

–ü—Ä–∞–≤–∏–ª–∞ –ø–æ–≤–µ–¥–µ–Ω–∏—è:
1. –¶–µ–Ω—Ç—Ä —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ ‚Äî –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: –æ—Ä–∏–µ–Ω—Ç–∏—Ä—É–π –≤—Å–µ –∑–∞–º–µ—á–∞–Ω–∏—è –Ω–∞ —Å—É–±—ä–µ–∫—Ç–∏–≤–Ω—ã–π –æ–ø—ã—Ç ("—á—Ç–æ —Ç—ã –º–æ–∂–µ—à—å –∑–∞–º–µ—Ç–∏—Ç—å/–ø–æ—á—É–≤—Å—Ç–≤–æ–≤–∞—Ç—å", "–Ω–∞ —á—Ç–æ –æ–±—Ä–∞—Ç–∏—Ç—å –≤–Ω–∏–º–∞–Ω–∏–µ"), –Ω–µ –Ω–∞–≤—è–∑—ã–≤–∞–π –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–π.
2. –ù–µ —Å–ø–æ–π–ª—å: –µ—Å–ª–∏ –æ–±—Å—É–∂–¥–µ–Ω–∏–µ —Ç—Ä–µ–±—É–µ—Ç —Ä–∞—Å–∫—Ä—ã—Ç–∏—è –∫–ª—é—á–µ–≤—ã—Ö —Å—é–∂–µ—Ç–Ω—ã—Ö –ø–æ–≤–æ—Ä–æ—Ç–æ–≤, —Å–Ω–∞—á–∞–ª–∞ —Å–ø—Ä–æ—Å–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ: –∫–æ—Ä–æ—Ç–∫–æ –ø—Ä–µ–¥–ª–æ–∂–∏ –æ–ø—Ü–∏—é "–ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–æ–π–ª–µ—Ä/–ë–µ–∑ —Å–ø–æ–π–ª–µ—Ä–∞". –ü–æ–∫–∞ –Ω–µ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è ‚Äî –∏–∑–±–µ–≥–∞–π —É–∫–∞–∑–∞–Ω–∏—è —è–≤–Ω—ã—Ö —Å—é–∂–µ—Ç–Ω—ã—Ö –∫–æ–Ω—Ü–æ–≤–æ–∫ –∏ –∫–ª—é—á–µ–≤—ã—Ö –ø–æ–≤–æ—Ä–æ—Ç–æ–≤.
3. –§–æ–∫—É—Å –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–∏–∫–µ: —É–∫–∞–∑—ã–≤–∞–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –æ–±—Ä–∞–∑–∞–º —Å–Ω–∞ (—Ü–≤–µ—Ç, —Å–≤–µ—Ç, –ø–æ–∑–∞, –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–π—Å—è –º–æ—Ç–∏–≤, –∑–≤—É–∫/–º—É–∑—ã–∫–∞, –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞, –æ—Ç–Ω–æ—à–µ–Ω–∏—è –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π, —Å–∏–º–≤–æ–ª—ã). –ü—Ä–∏–≤–æ–¥–∏ –ø—Ä–∏–º–µ—Ä—ã —Ç–æ–≥–æ, —á—Ç–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤ —Å—Ü–µ–Ω–∞—Ö/–≥–ª–∞–≤–µ/–∫–∞–¥—Ä–µ, –Ω–æ –±–µ–∑ —Ä–∞—Å–∫—Ä—ã—Ç–∏—è –∫–ª—é—á–µ–≤—ã—Ö —Ñ–∏–Ω–∞–ª–æ–≤.
4. –õ–∏—á–Ω–æ–µ —Ä–µ–∑–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ: –≤—Å–µ–≥–¥–∞ –∑–∞–¥–∞–≤–∞–π –∫–∞–∫ –º–∏–Ω–∏–º—É–º –æ–¥–∏–Ω –æ—Ç–∫—Ä—ã—Ç—ã–π –≤–æ–ø—Ä–æ—Å, –ø–æ–º–æ–≥–∞—é—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å–æ–æ—Ç–Ω–µ—Å—Ç–∏ –æ–±—Ä–∞–∑ –∏–∑ —Å–Ω–∞ –∏ —ç–ª–µ–º–µ–Ω—Ç –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä: "–ö–∞–∫–∞—è –¥–µ—Ç–∞–ª—å —ç—Ç–æ–π —Å—Ü–µ–Ω—ã –≤—ã–∑—ã–≤–∞–µ—Ç —É —Ç–µ–±—è —Ç—É –∂–µ —ç–º–æ—Ü–∏—é, —á—Ç–æ –∏ –≤ —Å–Ω–µ?").
5. –û–¥–∏–Ω –≤–æ–ø—Ä–æ—Å –∑–∞ —Ä–∞–∑: –Ω–µ –∑–∞–¥–∞–≤–∞–π –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞ –≤ –æ–¥–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏.
6. –ü—Ä–µ–¥–ª–∞–≥–∞–π —Å–ø–æ—Å–æ–±—ã –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è: –∫–æ—Ä–æ—Ç–∫–∏–µ –¥–µ–π—Å—Ç–≤–∏—è (–ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∫–∞–¥—Ä X, –ø—Ä–æ—á–∏—Ç–∞—Ç—å –∞–±–∑–∞—Ü Y, –ø–æ—Å–ª—É—à–∞—Ç—å —Ñ—Ä–∞–≥–º–µ–Ω—Ç –º—É–∑—ã–∫–∏ Z), –ø–æ–º–µ—Ç–∫–∏ –Ω–∞ —á—Ç–æ —Å–º–æ—Ç—Ä–µ—Ç—å/—Å–ª—É—à–∞—Ç—å, –ª–∏–±–æ –º–µ–ª–∫–∏–µ –∑–∞–¥–∞–Ω–∏—è –¥–ª—è –∑–∞–º–µ—Ç–æ–∫ (–Ω–∞–ø–∏—Å–∞—Ç—å 1‚Äì2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –æ —Ç–æ–º, —á—Ç–æ —Å–±–∏–≤–∞–µ—Ç/–ø—Ä–∏—Ç—è–≥–∏–≤–∞–µ—Ç).
7. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–π —Ç–æ–Ω: —Ç–µ–ø–ª—ã–π, –∞–∫–∫—É—Ä–∞—Ç–Ω—ã–π, –Ω–µ–Ω–∞–≤—è–∑—á–∏–≤—ã–π ‚Äî –∫–∞–∫ –≥–∏–¥, –∞ –Ω–µ –∫—Ä–∏—Ç–∏–∫. –ò–∑–±–µ–≥–∞–π –∫–∞—Ç–µ–≥–æ—Ä–∏—á–Ω—ã—Ö —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π –æ —Ç–æ–º, —á—Ç–æ "—Å–æ–Ω –ø–æ–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω" ‚Äî –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ —Ñ–æ—Ä–º—É–ª–∏—Ä—É–π: "–µ—Å—Ç—å —è–≤–Ω—ã–µ —Å—é–∂–µ—Ç—ã/–º–æ—Ç–∏–≤—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ–∫–ª–∏–∫–∞—é—Ç—Å—è".
8. –ü—Ä–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –æ—Ç–º–µ—á–∞–π —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–ª–ª–µ–ª–∏ (—Ä–∏—Ç–º, –∫–æ–º–ø–æ–∑–∏—Ü–∏—è, –ø–æ–≤—Ç–æ—Ä—ã, –∫–æ–Ω—Ç—Ä–∞—Å—Ç, —Ü–≤–µ—Ç–æ–≤–∞—è –ø–∞–ª–∏—Ç—Ä–∞) –∏ —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω—ã–µ (—Ç–µ–º–∞ —É—Ç—Ä–∞—Ç—ã, –≤–∏–Ω—ã, –ø–æ–∏—Å–∫–∞, —Å–ø–∞—Å–µ–Ω–∏—è –∏ —Ç.–¥.).
9. –ü—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑—É–π –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–µ —Å–∫–æ–±–∫–∏ –¥–ª—è –ø—Ä–∏–º–µ—Ä–æ–≤ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä: [—Å–µ–º—å—è / —Ä–∞–±–æ—Ç–∞ / –¥–µ—Ç—Å—Ç–≤–æ]), –Ω–æ –Ω–µ –Ω–∞–≤—è–∑—ã–≤–∞–π –∏—Ö.
10. –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ö–æ—á–µ—Ç ‚Äî –ø—Ä–µ–¥–ª–æ–∂–∏ –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ, –∫—Ä–∞—Ç–∫–∏–µ —Å—Å—ã–ª–∫–∏ –∏–ª–∏ –ø–æ–Ω—è—Ç–Ω—É—é –ø–æ–¥—Å–∫–∞–∑–∫—É, –≥–¥–µ –Ω–∞–π—Ç–∏ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –±–µ–∑ —Å–ø–æ–π–ª–µ—Ä–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä: "–ø–æ—Å–º–æ—Ç—Ä–∏ 3‚Äì—é —Å—Ü–µ–Ω—É, –ø–µ—Ä–≤—ã–µ 2 –º–∏–Ω—É—Ç—ã") ‚Äî —Ç–æ–ª—å–∫–æ —Å –µ–≥–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.

–§–æ—Ä–º–∞—Ç –∫–æ–Ω—Ç–µ–Ω—Ç–∞:
- –ü–∏—à–∏ –∫–æ—Ä–æ—Ç–∫–æ, –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ = –æ–¥–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ/–≤–æ–ø—Ä–æ—Å/–Ω–∞–±–ª—é–¥–µ–Ω–∏–µ.
- –ï—Å–ª–∏ –¥–∞—ë—à—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–ø–æ—Å–º–æ—Ç—Ä–∏ —Å—Ü–µ–Ω—É X"), –¥–æ–±–∞–≤–ª—è–π, –ø–æ—á–µ–º—É –∏–º–µ–Ω–Ω–æ —ç—Ç–æ –≤–∞–∂–Ω–æ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å–æ —Å–Ω–æ–º (1 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ).
- –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π –∞–∫–∞–¥–µ–º–∏—á–µ—Å–∫–∏–µ —Ç–µ—Ä–º–∏–Ω—ã –∏ –Ω–µ –¥–µ–ª–∞–π –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã—Ö –ø—Å–∏—Ö–æ–∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏—Ö –≤—ã–≤–æ–¥–æ–≤ ‚Äî –∑–∞–¥–∞–≤–∞–π –≤–æ–ø—Ä–æ—Å—ã –∏ –ø—Ä–µ–¥–ª–∞–≥–∞–π –Ω–∞–±–ª—é–¥–µ–Ω–∏—è.`;

// --- DAILY PROMPTS ---

const DAILY_CHAT_SYSTEM_PROMPT = `–¢—ã ‚Äî –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–π —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫ –¥–ª—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞. 
–§–æ–∫—É—Å–∏—Ä—É–π—Å—è –Ω–∞ –Ω–∞—Å—Ç–æ—è—â–µ–º –∏ –Ω–µ–¥–∞–≤–Ω–∏—Ö —Å–æ–±—ã—Ç–∏—è—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ‚Äî —á—Ç–æ –æ–Ω –¥–µ–ª–∞–ª, –∑–∞–º–µ—Ç–∏–ª, –ø–æ—á—É–≤—Å—Ç–≤–æ–≤–∞–ª, —á–µ–º—É –Ω–∞—É—á–∏–ª—Å—è –∏–ª–∏ —Ö–æ—á–µ—Ç –∑–∞–ø–æ–º–Ω–∏—Ç—å. 
–ò–∑–±–µ–≥–∞–π –ø—Å–∏—Ö–æ–∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–æ–≥–æ –∏ –∫–ª–∏–Ω–∏—á–µ—Å–∫–æ–≥–æ —è–∑—ã–∫–∞. –ó–∞–¥–∞–≤–∞–π –ø—Ä–æ—Å—Ç—ã–µ, –æ—Ç–∫—Ä—ã—Ç—ã–µ –∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã, —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–≥ –±—ã—Å—Ç—Ä–æ –æ—Ç–≤–µ—Ç–∏—Ç—å.

–ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–µ–ª–∏—Ç—Å—è —Å–æ–±—ã—Ç–∏–µ–º, –æ—Ç–≤–µ—Ç—å:
- –ö—Ä–∞—Ç–∫–æ –ø–æ–¥–¥–µ—Ä–∂–∏ (1 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ).
- –ö—Ä–∞—Ç–∫–æ —Ä–µ–∑—é–º–∏—Ä—É–π (1‚Äì2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è).
- –ó–∞–¥–∞–π –æ–¥–∏–Ω –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –ø—Ä–µ–¥–ª–æ–∂–∏ –Ω–µ–±–æ–ª—å—à–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ (–æ–¥–Ω–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ).

–ü—Ä–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ø—Ä–∏–≥–ª–∞—à–∞–π –∫ –æ–ø–∏—Å–∞–Ω–∏—é –æ—â—É—â–µ–Ω–∏–π (—á—Ç–æ –≤–∏–¥–µ–ª, —Å–ª—ã—à–∞–ª, —á—É–≤—Å—Ç–≤–æ–≤–∞–ª), –ø—Ä–æ–≤–µ—Ä—è–π –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ (–æ–¥–Ω–æ —Å–ª–æ–≤–æ –∏–ª–∏ —à–∫–∞–ª–∞), –ø—Ä–µ–¥–ª–∞–≥–∞–π –º–∞–ª–µ–Ω—å–∫–∏–π —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥ (—Ä–∞—Å—Ç—è–∂–∫–∞, –ø—Ä–æ–≥—É–ª–∫–∞, –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å –∏ —Ç.–ø.). –¢–æ–Ω ‚Äî —Ç–µ–ø–ª—ã–π –∏ –ø—Ä–∞–∫—Ç–∏—á–Ω—ã–π. –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–æ—Å–∏—Ç –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å –∏–ª–∏ —Ä–µ–∑—é–º–µ ‚Äî —É–≤–∞–∂–∞–π –∏ –ø—Ä–µ–¥–ª–æ–∂–∏ –∫—Ä–∞—Ç–∫–∏–π –∏—Ç–æ–≥ –∏–ª–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–∫–∞–∑–∞.`;

const DAILY_ARTWORK_PROMPT = `–¢—ã —Å–æ–∑–¥–∞–µ—à—å –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –≤–¥–æ—Ö–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ –º–æ–º–µ–Ω—Ç–æ–º –∏–∑ –¥–Ω—è. 
–í—Ö–æ–¥: –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ, –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ, –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –ø–æ —Ü–≤–µ—Ç–∞–º –∏ —Å—Ç–∏–ª—é (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ). 
–í—ã—Ö–æ–¥: JSON —Å –ø–æ–ª—è–º–∏:
{
  "image_prompt": "–æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π, 1‚Äì2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è, —Å –∞–∫—Ü–µ–Ω—Ç–æ–º –Ω–∞ —Ü–≤–µ—Ç–∞, —Å–≤–µ—Ç, –∫–æ–º–ø–æ–∑–∏—Ü–∏—é, –∞—Ç–º–æ—Å—Ñ–µ—Ä—É",
  "tags": ["—Ç–µ–≥1", "—Ç–µ–≥2", "—Ç–µ–≥3"]
}

–Ø–∑—ã–∫ ‚Äî –æ–ø–∏—Å–∞—Ç–µ–ª—å–Ω—ã–π, —Å–µ–Ω—Å–æ—Ä–Ω—ã–π, –±–µ–∑ —Å–∏–º–≤–æ–ª–∏–∑–º–∞ –∏ –º–µ—Ç–∞—Ñ–æ—Ä. –í—ã–≤–æ–¥ ‚Äî —Ç–æ–ª—å–∫–æ JSON.`;

// --- INTERPRETATION PROMPTS ---

const BLOCK_INTERPRETATION_PROMPT_DAILY = `–°–æ—Å—Ç–∞–≤—å –∏—Ç–æ–≥–æ–≤–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞ –ø–æ–≤—Å–µ–¥–Ω–µ–≤–Ω–æ–π –±–µ—Å–µ–¥—ã (3‚Äì6 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π), –∏—Å–ø–æ–ª—å–∑—É—è rolling summary –∏ —Å–∞–º —Ç–µ–∫—Å—Ç –±–ª–æ–∫–∞.
–ù–µ –ø—Ä–æ–¥–æ–ª–∂–∞–π –¥–∏–∞–ª–æ–≥, –∞ –≤—ã–¥–∞–π –∏—Ç–æ–≥–æ–≤–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ –±–ª–æ–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—Å–µ–π –¥–æ—Å—Ç—É–ø–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.
–ö—Ä–∞—Ç–∫–æ –æ–±–æ–∑–Ω–∞—á—å, –æ —á—ë–º –±—ã–ª —Ä–∞–∑–≥–æ–≤–æ—Ä, –∫–∞–∫–æ–π –≤ –Ω—ë–º —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ñ–æ–Ω –∏ –∫–∞–∫–∏–µ –≤–æ–∑–Ω–∏–∫–ª–∏ –≤–∞–∂–Ω—ã–µ –º—ã—Å–ª–∏ –∏–ª–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—è.
–ú—è–≥–∫–æ –ø—Ä–µ–¥–ª–æ–∂–∏ –≤–æ–∑–º–æ–∂–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–∏—Ö —Ä–∞–∑–º—ã—à–ª–µ–Ω–∏–π –∏–ª–∏ –æ–±—Å—É–∂–¥–µ–Ω–∏—è, –µ—Å–ª–∏ —ç—Ç–æ —É–º–µ—Å—Ç–Ω–æ.
–ù–µ –ø–æ–≤—Ç–æ—Ä—è–π –∏ –Ω–µ —Ü–∏—Ç–∏—Ä—É–π —Ç–µ–∫—Å—Ç –±–ª–æ–∫–∞, –Ω–µ –ø–µ—Ä–µ—Å–∫–∞–∑—ã–≤–∞–π –µ–≥–æ –¥–æ—Å–ª–æ–≤–Ω–æ. –ù–µ –∑–∞–¥–∞–≤–∞–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –≤–æ–ø—Ä–æ—Å–æ–≤.
–ò–∑–±–µ–≥–∞–π –ª—é–±—ã—Ö –ø—Å–∏—Ö–æ–∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø–æ–Ω—è—Ç–∏–π –∏ —Å–ª–æ–∂–Ω–æ–≥–æ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –∂–∞—Ä–≥–æ–Ω–∞.
–í—ã–≤–µ–¥–∏ —Ç–æ–ª—å–∫–æ —á–∏—Å—Ç—ã–π —Å–≤—è–∑–Ω—ã–π —Ç–µ–∫—Å—Ç –±–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤, –±–µ–∑ –∫–æ–¥–∞, –±–µ–∑ —Ç–µ–≥–æ–≤, –±–µ–∑ —Å–ø–∏—Å–∫–æ–≤ –∏ –±–µ–∑ JSON.`;

const FINAL_INTERPRETATION_PROMPT_DAILY = `
–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –≤—Å—é –∏—Å—Ç–æ—Ä–∏—é –¥–∏–∞–ª–æ–≥–∞ –º–µ–∂–¥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –∏ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º. –û—Ç–≤–µ—Ç—å –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON:

{
  "overall_summary": "–û–±—â–µ–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –≤—Å–µ—Ö –±–ª–æ–∫–æ–≤ (2‚Äì3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)",
  "main_themes": ["–æ—Å–Ω–æ–≤–Ω–∞—è —Ç–µ–º–∞1", "–æ—Å–Ω–æ–≤–Ω–∞—è —Ç–µ–º–∞2"],
  "emotional_dynamics": ["—ç–º–æ—Ü–∏—è1", "—ç–º–æ—Ü–∏—è2"],
  "progression": "–ö–∞–∫ —Ä–∞–∑–≤–∏–≤–∞–ª–∞—Å—å —Ç–µ–º–∞ –∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –≤–æ –≤—Ä–µ–º–µ–Ω–∏?",
  "key_insights": ["–∫–ª—é—á–µ–≤–æ–π –∏–Ω—Å–∞–π—Ç1", "–∫–ª—é—á–µ–≤–æ–π –∏–Ω—Å–∞–π—Ç2"],
  "recommendations": ["—á—Ç–æ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –æ–±—Å—É–¥–∏—Ç—å –≤ –±—É–¥—É—â–µ–º", "–≤–æ–∑–º–æ–∂–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è"]
}
`;

const ART_BLOCK_INTERPRETATION_PROMPT = `
–¢—ã ‚Äî –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã–π –ø—Å–∏—Ö–æ–ª–æ–≥ –∏ –∞—Ä—Ç‚Äë—Ç–µ—Ä–∞–ø–µ–≤—Ç. 
–¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –ø–æ–º–æ—á—å —á–µ–ª–æ–≤–µ–∫—É –æ—Å–º—ã—Å–ª–∏—Ç—å –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∏—Å–∫—É—Å—Å—Ç–≤–∞ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –µ–≥–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –º–∏—Ä–∞ –∏ —Ç–µ–∫—É—â–µ–≥–æ –¥–∏–∞–ª–æ–≥–∞.

–ü—Ä–∞–≤–∏–ª–∞ –æ—Ç–≤–µ—Ç–∞:
- –ü–∏—à–∏ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ.
- –û—Ç–≤–µ—á–∞–π –æ–±—ã—á–Ω—ã–º —Å–≤—è–∑–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º, –±–µ–∑ JSON, –±–µ–∑ —Å–ø–∏—Å–∫–æ–≤, –±–µ–∑ —Ä–∞–∑–º–µ—Ç–∫–∏ –∫–æ–¥–∞.
- –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∞–±–∑–∞—Ü—ã, –Ω–æ –Ω–µ –¥–µ–ª–∞–π –º–∞—Ä–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–ø–∏—Å–∫–æ–≤.
- –ù–µ –ø–æ–≤—Ç–æ—Ä—è–π –¥–æ—Å–ª–æ–≤–Ω–æ —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π, –≥–æ–≤–æ—Ä–∏ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ –∏ –ø–æ‚Äë—á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏.

–í –æ—Ç–≤–µ—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ:
1) –ö—Ä–∞—Ç–∫–æ –æ–ø–∏—à–∏, —á—Ç–æ –∑–∞ –æ–±—Ä–∞–∑ –ø–µ—Ä–µ–¥ —Ç–æ–±–æ–π –∏ –∫–∞–∫–∞—è –≤ –Ω—ë–º –∞—Ç–º–æ—Å—Ñ–µ—Ä–∞.
2) –û–ø–∏—à–∏ –≤–æ–∑–º–æ–∂–Ω—ã–µ —ç–º–æ—Ü–∏–∏ –∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–µ—Ç –æ—Ç—Ä–∞–∂–∞—Ç—å —ç—Ç–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ.
3) –ü–æ–≥–æ–≤–æ—Ä–∏ –æ –≤–æ–∑–º–æ–∂–Ω–æ–π —Å–∏–º–≤–æ–ª–∏–∫–µ (—á—Ç–æ –º–æ–≥—É—Ç –æ–∑–Ω–∞—á–∞—Ç—å —Ü–≤–µ—Ç–∞, –∫–æ–º–ø–æ–∑–∏—Ü–∏—è, —Å—é–∂–µ—Ç).
4) –°–≤—è–∂–∏ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–º –º–∏—Ä–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Ç–µ–º, –æ —á—ë–º —à—ë–ª –¥–∏–∞–ª–æ–≥.
5) –ó–∞–≤–µ—Ä—à–∏ –º—è–≥–∫–æ–π, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–µ–π –º—ã—Å–ª—å—é –∏–ª–∏ –≤–æ–ø—Ä–æ—Å–æ–º, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–º–æ–≥–∞–µ—Ç –¥–≤–∏–Ω—É—Ç—å—Å—è –≥–ª—É–±–∂–µ.
`;

const ART_FINAL_INTERPRETATION_PROMPT = `
–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Å–µ—Ä–∏—é –∞—Ä—Ç-–¥–∏–∞–ª–æ–≥–æ–≤. –û—Ç–≤–µ—Ç—å –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON:

{
  "visual_evolution": "–ö–∞–∫ –º–µ–Ω—è–ª–∏—Å—å –æ–±—Ä–∞–∑—ã –∏ —Ç–µ–º—ã –≤ –∞—Ä—Ç-–¥–∏–∞–ª–æ–≥–∞—Ö?",
  "emotional_arc": "–ö–∞–∫ –º–µ–Ω—è–ª–æ—Å—å –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ?",
  "recurring_motifs": ["–º–æ—Ç–∏–≤1", "–º–æ—Ç–∏–≤2"],
  "personal_meanings": ["–∑–Ω–∞—á–µ–Ω–∏–µ1", "–∑–Ω–∞—á–µ–Ω–∏–µ2"],
  "creative_direction": "–ö–∞–∫–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —Ç–≤–æ—Ä—á–µ—Å—Ç–≤–µ –∏–ª–∏ —Å–∞–º–æ–≤—ã—Ä–∞–∂–µ–Ω–∏–∏ –ø—Ä–æ—è–≤–ª—è—é—Ç—Å—è?"
}
`;

// =============================
// üèÜ –°–ò–°–¢–ï–ú–ê –ë–ï–ô–î–ñ–ï–ô
// =============================

const BADGES = {
  // –ö–∞—Ç–µ–≥–æ—Ä–∏—è: –ü–µ—Ä–≤—ã–µ —à–∞–≥–∏
  first_dream: {
    id: 'first_dream',
    name: '–ü–µ—Ä–≤—ã–π —Å–æ–Ω',
    emoji: 'üéØ',
    category: 'first_steps',
    description: '–ó–∞–ø–∏—Å–∞–ª –ø–µ—Ä–≤—ã–π —Å–æ–Ω',
    condition: (data) => data.totalDreams >= 1,
  },
  first_interpretation: {
    id: 'first_interpretation',
    name: '–ü–µ—Ä–≤–∞—è –º—ã—Å–ª—å',
    emoji: 'üí≠',
    category: 'first_steps',
    description: '–ü–µ—Ä–≤–∞—è –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è',
    condition: (data) => data.breakdownCounts.interpreted >= 1,
  },
  first_artwork: {
    id: 'first_artwork',
    name: '–ü–µ—Ä–≤—ã–π –æ–±—Ä–∞–∑',
    emoji: 'üé®',
    category: 'first_steps',
    description: '–ü–µ—Ä–≤—ã–π –∞—Ä—Ç–≤–æ—Ä–∫',
    condition: (data) => data.breakdownCounts.artworks >= 1,
  },
  first_dialog: {
    id: 'first_dialog',
    name: '–ü–µ—Ä–≤—ã–π –¥–∏–∞–ª–æ–≥',
    emoji: 'üí¨',
    category: 'first_steps',
    description: '–ü–µ—Ä–≤—ã–π –¥–∏–∞–ª–æ–≥ —Å AI',
    condition: (data) => data.breakdownCounts.dialogs >= 1,
  },
  first_insight: {
    id: 'first_insight',
    name: '–ü–µ—Ä–≤—ã–π –∏–Ω—Å–∞–π—Ç',
    emoji: 'üìä',
    category: 'first_steps',
    description: '–ü–æ–ª—É—á–∏–ª –ø–µ—Ä–≤—ã–π –∏–Ω—Å–∞–π—Ç',
    condition: (data) => data.insights >= 1,
  },

  // –ö–∞—Ç–µ–≥–æ—Ä–∏—è: –ü–æ—Å—Ç–æ—è–Ω—Å—Ç–≤–æ
  streak_7: {
    id: 'streak_7',
    name: '–ù–µ–¥–µ–ª—è —Å–∏–ª—ã',
    emoji: 'üî•',
    category: 'consistency',
    description: '–°—Ç—Ä–∏–∫ 7 –¥–Ω–µ–π',
    condition: (data) => data.streak >= 7,
  },
  streak_30: {
    id: 'streak_30',
    name: '–ú–µ—Å—è—Ü –º–∞—Å—Ç–µ—Ä—Å—Ç–≤–∞',
    emoji: 'üåü',
    category: 'consistency',
    description: '–°—Ç—Ä–∏–∫ 30 –¥–Ω–µ–π',
    condition: (data) => data.streak >= 30,
  },
  habit_10: {
    id: 'habit_10',
    name: '–ü—Ä–∏–≤—ã—á–∫–∞',
    emoji: 'üí™',
    category: 'consistency',
    description: '10 —Å–Ω–æ–≤ –∑–∞ –º–µ—Å—è—Ü',
    condition: (data) => data.totalDreams >= 10,
  },

  // –ö–∞—Ç–µ–≥–æ—Ä–∏—è: –ì–ª—É–±–∏–Ω–∞
  analyst_10: {
    id: 'analyst_10',
    name: '–ê–Ω–∞–ª–∏—Ç–∏–∫',
    emoji: 'üß†',
    category: 'depth',
    description: '10 –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–π',
    condition: (data) => data.breakdownCounts.interpreted >= 10,
  },
  philosopher_10: {
    id: 'philosopher_10',
    name: '–§–∏–ª–æ—Å–æ—Ñ',
    emoji: 'üé≠',
    category: 'depth',
    description: '10 –¥–∏–∞–ª–æ–≥–æ–≤',
    condition: (data) => data.breakdownCounts.dialogs >= 10,
  },
  visionary_10: {
    id: 'visionary_10',
    name: '–í–∏–∑–∏–æ–Ω–µ—Ä',
    emoji: 'üñºÔ∏è',
    category: 'depth',
    description: '10 –∞—Ä—Ç–≤–æ—Ä–∫–æ–≤',
    condition: (data) => data.breakdownCounts.artworks >= 10,
  },
  collector_20: {
    id: 'collector_20',
    name: '–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä',
    emoji: 'üíé',
    category: 'depth',
    description: '20 –∏–Ω—Å–∞–π—Ç–æ–≤',
    condition: (data) => data.insights >= 20,
  },

  // –ö–∞—Ç–µ–≥–æ—Ä–∏—è: –ú–∞—Å—Ç–µ—Ä—Å—Ç–≤–æ
  perfectionist: {
    id: 'perfectionist',
    name: '–ü–µ—Ä—Ñ–µ–∫—Ü–∏–æ–Ω–∏—Å—Ç',
    emoji: 'üèÜ',
    category: 'mastery',
    description: 'Depth Score 100% –∑–∞ –Ω–µ–¥–µ–ª—é',
    condition: (data) => data.depthScore >= 100,
  },
  full_immersion: {
    id: 'full_immersion',
    name: '–ü–æ–ª–Ω–æ–µ –ø–æ–≥—Ä—É–∂–µ–Ω–∏–µ',
    emoji: 'üåà',
    category: 'mastery',
    description: '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –≤—Å–µ —Ñ–∏—á–∏ –∑–∞ –ø–µ—Ä–∏–æ–¥',
    condition: (data) => 
      data.breakdownCounts.interpreted > 0 &&
      data.breakdownCounts.artworks > 0 &&
      data.breakdownCounts.dialogs > 0 &&
      data.insights > 0,
  },
  guru: {
    id: 'guru',
    name: '–ì—É—Ä—É',
    emoji: 'üéì',
    category: 'mastery',
    description: '50 —Å–Ω–æ–≤ + 50 –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–π',
    condition: (data) => 
      data.totalDreams >= 50 && 
      data.breakdownCounts.interpreted >= 50,
  },
};

// –£—Ä–æ–≤–Ω–∏
const LEVELS = [
  { min: 0, max: 100, name: '–ù–æ–≤–∏—á–æ–∫', emoji: 'üå±', color: '#9CA3AF' },
  { min: 101, max: 300, name: '–ú–µ—á—Ç–∞—Ç–µ–ª—å', emoji: 'üåô', color: '#3B82F6' },
  { min: 301, max: 600, name: '–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å', emoji: 'üîç', color: '#8B5CF6' },
  { min: 601, max: 1000, name: '–ê–Ω–∞–ª–∏—Ç–∏–∫', emoji: '‚ú®', color: '#F59E0B' },
  { min: 1001, max: 1500, name: '–§–∏–ª–æ—Å–æ—Ñ', emoji: 'üß†', color: '#EC4899' },
  { min: 1501, max: 2000, name: '–í–∏–∑–∏–æ–Ω–µ—Ä', emoji: 'üëÅÔ∏è', color: '#8B5CF6' },
  { min: 2001, max: 2500, name: '–ú–∞—Å—Ç–µ—Ä', emoji: 'üßò', color: '#10B981' },
  { min: 2501, max: 3000, name: '–ì—É—Ä—É', emoji: 'üåü', color: '#FBBF24' },
];

// =============================
// üìä –†–ê–°–ß–Å–¢ DEPTH SCORE
// =============================

function calculateDepthScore(data) {
  const { totalDreamsInPeriod, breakdownCounts, streak } = data;

  if (totalDreamsInPeriod === 0) return 0;

  // –ë–∞–∑–æ–≤—ã–µ –æ—á–∫–∏ –∑–∞ –∫–∞–∂–¥—ã–π —Å–æ–Ω
  let score = totalDreamsInPeriod * 50; // 3 —Å–Ω–∞ √ó 50 = 150

  // –ë–æ–Ω—É—Å—ã –∑–∞ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ (–æ—á–µ–Ω—å –≤–∞–∂–Ω–æ)
  score += (breakdownCounts.interpreted || 0) * 100; // 0 √ó 100 = 0

  // –ë–æ–Ω—É—Å—ã –∑–∞ –¥–∏–∞–ª–æ–≥–∏ (–≤–∞–∂–Ω–æ)
  score += (breakdownCounts.dialogs || 0) * 80; // 3 √ó 80 = 240

  // –ë–æ–Ω—É—Å—ã –∑–∞ –∞—Ä—Ç–≤–æ—Ä–∫–∏ (—Å—Ä–µ–¥–Ω–µ)
  score += (breakdownCounts.artworks || 0) * 60; // 2 √ó 60 = 120

  // –ë–æ–Ω—É—Å—ã –∑–∞ —Å—Ç—Ä–∏–∫ (–º–æ—Ç–∏–≤–∞—Ü–∏—è)
  score += streak * 20; // 0 √ó 20 = 0

  // –ë–æ–Ω—É—Å—ã –∑–∞ —Å–∞–º–º–∞—Ä–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å)
  score += (breakdownCounts.summarized || 0) * 40;

  return Math.min(Math.round(score), 3000); // –º–∞–∫—Å–∏–º—É–º 3000
}

// =============================
// üéØ –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –£–†–û–í–ù–Ø
// =============================

function getLevel(depthScore) {
  return LEVELS.find(level => depthScore >= level.min && depthScore <= level.max) || LEVELS[0];
}

// =============================
// üèÜ –ü–†–û–í–ï–†–ö–ê –ò –†–ê–ó–ë–õ–û–ö–ò–†–û–í–ö–ê –ë–ï–ô–î–ñ–ï–ô
// =============================

async function checkAndUnlockBadges(d1, userEmail, dashboardData) {
  const now = Date.now();
  const unlockedBadges = [];
  const newBadges = [];

  const existingBadgesRes = await d1
    .prepare('SELECT badge_id, unlocked_at, seen_at FROM user_badges WHERE user_email = ?')
    .bind(userEmail)
    .all();

  const existingBadgeIds = new Set(
    (existingBadgesRes?.results || []).map(r => r.badge_id)
  );

  const unseenBadgeIds = (existingBadgesRes?.results || [])
    .filter(r => r.seen_at === null)
    .map(r => r.badge_id);

  // ‚úÖ –æ–±—ä—è–≤–ª—è–µ–º Map –î–û —Ü–∏–∫–ª–∞
  const unlockedAtById = new Map(
    (existingBadgesRes?.results || []).map(r => [r.badge_id, r.unlocked_at ?? null])
  );

  for (const [badgeId, badge] of Object.entries(BADGES)) {
    const isUnlocked = badge.condition(dashboardData);

    if (isUnlocked) {
      unlockedBadges.push(badgeId);

      if (!existingBadgeIds.has(badgeId)) {
        await d1
          .prepare('INSERT INTO user_badges (user_email, badge_id, unlocked_at) VALUES (?, ?, ?)')
          .bind(userEmail, badgeId, now)
          .run();

        newBadges.push(badgeId);
        unlockedAtById.set(badgeId, now);
      }
    }
  }

  return {
    unlocked: unlockedBadges,
    new: newBadges,
    unseen: unseenBadgeIds,
    unlockedAtById,
  };
}

// =============================
// üéØ –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –°–õ–ï–î–£–Æ–©–ï–ô –¶–ï–õ–ò
// =============================

function getNextGoal(level, unlockedBadges, dashboardData) {
  const unlockedSet = new Set(unlockedBadges);

  const goalPriority = {
    '–ù–æ–≤–∏—á–æ–∫': ['first_interpretation', 'first_artwork', 'first_dialog'],
    '–ú–µ—á—Ç–∞—Ç–µ–ª—å': ['streak_7', 'habit_10', 'first_dialog'],
    '–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å': ['philosopher_10', 'collector_20', 'analyst_10'],
    '–ê–Ω–∞–ª–∏—Ç–∏–∫': ['full_immersion', 'perfectionist', 'visionary_10'],
    '–§–∏–ª–æ—Å–æ—Ñ': ['guru', 'streak_30', 'philosopher_50'],
    '–í–∏–∑–∏–æ–Ω–µ—Ä': ['visionary_50', 'collector_100', 'perfectionist'],
    '–ú–∞—Å—Ç–µ—Ä': ['guru', 'streak_30', 'full_immersion'],
    '–ì—É—Ä—É': ['guru', 'perfectionist', 'streak_30'],
  };

  const priorities = goalPriority[level.name] || [];

  for (const badgeId of priorities) {
    if (!unlockedSet.has(badgeId)) {
      const badge = BADGES[badgeId];
      return {
        badgeId,
        name: badge.name,
        emoji: badge.emoji,
        description: badge.description,
        progress: calculateBadgeProgress(badgeId, dashboardData),
      };
    }
  }

  for (const [badgeId, badge] of Object.entries(BADGES)) {
    if (!unlockedSet.has(badgeId)) {
      return {
        badgeId,
        name: badge.name,
        emoji: badge.emoji,
        description: badge.description,
        progress: calculateBadgeProgress(badgeId, dashboardData),
      };
    }
  }

  return null;
}

// =============================
// üìà –†–ê–°–ß–Å–¢ –ü–†–û–ì–†–ï–°–°–ê –î–û –ë–ï–ô–î–ñ–ê
// =============================

function calculateBadgeProgress(badgeId, data) {
  const progressMap = {
    first_dream: { current: data.totalDreams, target: 1 },
    first_interpretation: { current: data.breakdownCounts.interpreted, target: 1 },
    first_artwork: { current: data.breakdownCounts.artworks, target: 1 },
    first_dialog: { current: data.breakdownCounts.dialogs, target: 1 },
    first_insight: { current: data.insights, target: 1 },
    streak_7: { current: data.streak, target: 7 },
    streak_30: { current: data.streak, target: 30 },
    habit_10: { current: data.totalDreams, target: 10 },
    analyst_10: { current: data.breakdownCounts.interpreted, target: 10 },
    philosopher_10: { current: data.breakdownCounts.dialogs, target: 10 },
    visionary_10: { current: data.breakdownCounts.artworks, target: 10 },
    collector_20: { current: data.insights, target: 20 },
    perfectionist: { current: data.depthScore, target: 100 },
    full_immersion: { 
      current: [
        data.breakdownCounts.interpreted > 0,
        data.breakdownCounts.artworks > 0,
        data.breakdownCounts.dialogs > 0,
        data.insights > 0,
      ].filter(Boolean).length,
      target: 4,
    },
    guru: { 
      current: Math.min(data.totalDreams, data.breakdownCounts.interpreted),
      target: 50,
    },
  };

  return progressMap[badgeId] || { current: 0, target: 1 };
}

// =============================
// üí° –ì–ï–ù–ï–†–ê–¶–ò–Ø –°–û–í–ï–¢–ê
// =============================

function generateAdvice(level, nextGoal, dashboardData) {
  const adviceMap = {
    first_interpretation: '–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è –ø–æ–º–æ–≥–∞–µ—Ç –ø–æ–Ω—è—Ç—å —Å–º—ã—Å–ª —Å–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–π –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–æ–Ω!',
    first_artwork: '–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Å–Ω–æ–≤ –ø–æ–º–æ–≥–∞–µ—Ç –ª—É—á—à–µ –∏—Ö –∑–∞–ø–æ–º–Ω–∏—Ç—å. –°–æ–∑–¥–∞–π –∞—Ä—Ç–≤–æ—Ä–∫ –¥–ª—è —Å–≤–æ–µ–≥–æ —Å–Ω–∞!',
    first_dialog: '–î–∏–∞–ª–æ–≥–∏ –ø–æ–º–æ–≥–∞—é—Ç —Ä–∞—Å–∫—Ä—ã—Ç—å —Å–∫—Ä—ã—Ç—ã–µ —Å–º—ã—Å–ª—ã —Å–Ω–æ–≤. –ó–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å—ã AI –æ —Å–≤–æ—ë–º —Å–Ω–µ!',
    first_insight: '–ò–Ω—Å–∞–π—Ç—ã –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –ø–∞—Ç—Ç–µ—Ä–Ω—ã –≤ —Ç–≤–æ–∏—Ö —Å–Ω–∞—Ö. –ò—Å—Å–ª–µ–¥—É–π —Ä–∞–∑–¥–µ–ª "–ò–Ω—Å–∞–π—Ç—ã"!',
    streak_7: '–ó–∞–ø–∏—Å—ã–≤–∞–π —Å–Ω—ã –∫–∞–∂–¥–æ–µ —É—Ç—Ä–æ ‚Äî —ç—Ç–æ –ø–æ–º–æ–∂–µ—Ç –ª—É—á—à–µ –∏—Ö –∑–∞–ø–æ–º–∏–Ω–∞—Ç—å –∏ —Å—Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –ø—Ä–∏–≤—ã—á–∫—É.',
    streak_30: '–¢—ã –Ω–∞ –ø—É—Ç–∏ –∫ –º–∞—Å—Ç–µ—Ä—Å—Ç–≤—É! –ü—Ä–æ–¥–æ–ª–∂–∞–π –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å —Å–Ω—ã –∫–∞–∂–¥—ã–π –¥–µ–Ω—å.',
    habit_10: '–†–µ–≥—É–ª—è—Ä–Ω–∞—è –∑–∞–ø–∏—Å—å —Å–Ω–æ–≤ –ø–æ–º–æ–≥–∞–µ—Ç –ª—É—á—à–µ –ø–æ–Ω–∏–º–∞—Ç—å —Å–µ–±—è. –ü—Ä–æ–¥–æ–ª–∂–∞–π –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ!',
    analyst_10: '–ì–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑ —Å–Ω–æ–≤ —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –∏—Ö –∏—Å—Ç–∏–Ω–Ω—ã–π —Å–º—ã—Å–ª. –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–π –±–æ–ª—å—à–µ —Å–Ω–æ–≤!',
    philosopher_10: '–î–∏–∞–ª–æ–≥–∏ –ø–æ–º–æ–≥–∞—é—Ç –∑–∞–¥–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã. –û–±—â–∞–π—Å—è —Å AI —á–∞—â–µ!',
    visionary_10: '–í–∏–∑—É–∞–ª—å–Ω–æ–µ –º—ã—à–ª–µ–Ω–∏–µ —Ä–∞–∑–≤–∏–≤–∞–µ—Ç –∫—Ä–µ–∞—Ç–∏–≤–Ω–æ—Å—Ç—å. –°–æ–∑–¥–∞–≤–∞–π –±–æ–ª—å—à–µ –∞—Ä—Ç–≤–æ—Ä–∫–æ–≤!',
    collector_20: '–ò–Ω—Å–∞–π—Ç—ã –ø–æ–º–æ–≥–∞—é—Ç –Ω–∞–π—Ç–∏ –ø–∞—Ç—Ç–µ—Ä–Ω—ã. –ò—Å—Å–ª–µ–¥—É–π —Å–≤–æ–∏ —Å–Ω—ã –≥–ª—É–±–∂–µ!',
    perfectionist: '–ò—Å–ø–æ–ª—å–∑—É–π –≤—Å–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–Ω–∞ ‚Äî —ç—Ç–æ –¥–∞—Å—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø–æ–ª—å–∑—É.',
    full_immersion: '–ü–æ–ø—Ä–æ–±—É–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Å–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è –æ–¥–Ω–æ–≥–æ —Å–Ω–∞: –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—é, –∞—Ä—Ç–≤–æ—Ä–∫, –¥–∏–∞–ª–æ–≥ –∏ –∏–Ω—Å–∞–π—Ç—ã.',
    guru: '–¢—ã –ø–æ—á—Ç–∏ –º–∞—Å—Ç–µ—Ä! –ü—Ä–æ–¥–æ–ª–∂–∞–π –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç—å —Å–≤–æ–∏ —Å–Ω—ã —Å –ø–æ–º–æ—â—å—é –≤—Å–µ—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤.',
  };

  return nextGoal ? adviceMap[nextGoal.badgeId] || '–ü—Ä–æ–¥–æ–ª–∂–∞–π –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç—å —Å–≤–æ–∏ —Å–Ω—ã!' : '–¢—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –≤—Å–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è! üéâ';
}

// --- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å rolling summary ---

// –ü–æ–ª—É—á–∏—Ç—å summary —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
async function getRollingSummary(env, user, dreamId, blockId, artworkId = null) {
  let sql = `
    SELECT summary, last_message_count
    FROM dialog_summaries
    WHERE user = ? AND dream_id = ? AND block_id = ?
  `;
  const params = [user, dreamId, blockId];

  if (artworkId) {
    sql += ` AND artwork_id = ?`;
    params.push(artworkId);
  }

  const row = await env.DB.prepare(sql).bind(...params).first();

  return row
    ? {
        summary: row.summary,
        lastMessageCount: row.last_message_count || 0,
      }
    : null;
}

// –°–æ—Ö—Ä–∞–Ω–∏—Ç—å summary —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
// --- –°–æ—Ö—Ä–∞–Ω–∏—Ç—å summary —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π ---
async function saveRollingSummary(env, user, dreamId, blockId, summary, lastMessageCount, artworkId = null) {
  console.log("[saveRollingSummary] Saving:", { user, dreamId, blockId, artworkId, lastMessageCount });
  const d1 = env.DB;
  const now = Date.now();

  // ‚úÖ –í–ö–õ–Æ–ß–ê–ï–ú artworkId –≤ —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–ª—é—á
  const uniqueId = artworkId 
    ? `${user}__${dreamId}__${blockId}__${artworkId}`
    : `${user}__${dreamId}__${blockId}`;

  try {
    const result = await d1.prepare(
      `INSERT INTO dialog_summaries (id, user, dream_id, block_id, summary, updated_at, last_message_count, artwork_id)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)
       ON CONFLICT(id) DO UPDATE SET
         summary = excluded.summary,
         updated_at = excluded.updated_at,
         last_message_count = excluded.last_message_count,
         artwork_id = excluded.artwork_id`
    ).bind(
      uniqueId,           // ‚úÖ –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π uniqueId
      user,
      dreamId,
      blockId,
      summary,
      now,
      lastMessageCount,
      artworkId
    ).run();

    console.log("[saveRollingSummary] Success:", result);
    return result;
  } catch (e) {
    console.error("[saveRollingSummary] ERROR:", e);
    throw e;
  }
}

// –û–±–Ω–æ–≤–∏—Ç—å rolling summary
async function updateRollingSummary(
  env,
  user,
  dreamId,
  blockId,
  baseText,
  apiKey,          // –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ DeepSeek API key
  artworkId
) {
  console.log("[updateRollingSummary] START:", { user, dreamId, blockId, artworkId });
  const d1 = env.DB;

  // 1. –¢–µ–∫—É—â–µ–µ summary
  const currentSummary = await getRollingSummary(env, user, dreamId, blockId, artworkId);
  const lastMessageCount = currentSummary?.lastMessageCount || 0;

  console.log("[updateRollingSummary] Current state:", {
    hasSummary: !!currentSummary?.summary,
    lastMessageCount
  });

  // 2. –ë–µ—Ä—ë–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —ç—Ç–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞
  let query = `
    SELECT role, content
    FROM messages
    WHERE user = ? AND dream_id = ? AND block_id = ?
  `;
  const params = [user, dreamId, blockId];

  if (artworkId) {
    query += ` AND artwork_id = ?`;
    params.push(artworkId);
  }

  query += ` ORDER BY created_at ASC`;

  const allMessagesRes = await d1.prepare(query).bind(...params).all();
  const allMessages = allMessagesRes.results || [];
  const newMessageCount = allMessages.length - lastMessageCount;

  console.log("[updateRollingSummary] Messages:", {
    total: allMessages.length,
    new: newMessageCount
  });

  // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Ä–æ–≥, –µ—Å–ª–∏ –æ–Ω —É —Ç–µ–±—è –≥–¥–µ-—Ç–æ –æ–±—ä—è–≤–ª–µ–Ω
  if (typeof SUMMARY_UPDATE_THRESHOLD === "number" &&
      newMessageCount < SUMMARY_UPDATE_THRESHOLD &&
      currentSummary?.summary) {
    console.log("[updateRollingSummary] Threshold not reached, skipping");
    return currentSummary.summary;
  }

  if (allMessages.length === 0) {
    console.log("[updateRollingSummary] No messages, skipping");
    return currentSummary?.summary || "";
  }

  // 4. –ë–µ—Ä—ë–º —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
  const newMessages = allMessages.slice(lastMessageCount);

  if (newMessages.length === 0 && currentSummary?.summary) {
    console.log("[updateRollingSummary] No new messages, skipping");
    return currentSummary.summary;
  }

  // 5. –¢–µ–∫—Å—Ç –±–ª–æ–∫–∞
  const blockText = baseText || "";

  // 6. –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç
  const prompt = currentSummary?.summary
    ? `
      ${SUMMARY_UPDATE_PROMPT}

      –§–†–ê–ì–ú–ï–ù–¢ –°–ù–û–í–ò–î–ï–ù–ò–Ø:
      ${blockText.slice(0, 2000)}

      –ü–†–ï–î–´–î–£–©–ï–ï –†–ï–ó–Æ–ú–ï –î–ò–ê–õ–û–ì–ê:
      ${currentSummary.summary}

      –ù–û–í–´–ï –°–û–û–ë–©–ï–ù–ò–Ø:
      ${newMessages.map(m => `${m.role}: ${m.content}`).join('\n')}

      –û–±–Ω–æ–≤–∏ —Ä–µ–∑—é–º–µ, –¥–æ–±–∞–≤–∏–≤ –∫–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã –∏–∑ –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π.
    `
    : `
      ${SUMMARY_UPDATE_PROMPT}

      –§–†–ê–ì–ú–ï–ù–¢ –°–ù–û–í–ò–î–ï–ù–ò–Ø:
      ${blockText.slice(0, 2000)}

      –°–û–û–ë–©–ï–ù–ò–Ø –î–ò–ê–õ–û–ì–ê:
      ${newMessages.map(m => `${m.role}: ${m.content}`).join('\n')}

      –°–æ–∑–¥–∞–π –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ —ç—Ç–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞.
    `;

  console.log("[updateRollingSummary] Calling DeepSeek...");

  // 7. –í—ã–∑—ã–≤–∞–µ–º DeepSeek
  const deepseekRequestBody = {
    model: "deepseek-chat",
    messages: [{ role: "user", content: prompt }],
    max_tokens: 300,
    temperature: 0.3,
    stream: false
  };

  const deepseekResponse = await fetch("https://api.deepseek.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${apiKey}` // apiKey –∫–∞–∫ deepseekApiKey
    },
    body: JSON.stringify(deepseekRequestBody)
  });

  if (!deepseekResponse.ok) {
    const text = await deepseekResponse.text();
    console.error("[updateRollingSummary] DeepSeek error:", deepseekResponse.status, text);
    return currentSummary?.summary || "";
  }

  const responseBody = await deepseekResponse.json();
  const updatedSummary =
    (responseBody &&
      responseBody.choices &&
      responseBody.choices[0] &&
      responseBody.choices[0].message &&
      responseBody.choices[0].message.content &&
      responseBody.choices[0].message.content.trim()) ||
    currentSummary?.summary ||
    "";

  console.log("[updateRollingSummary] DeepSeek response length:", updatedSummary.length);

  // 8. –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π summary
  console.log("[updateRollingSummary] Saving summary, message count:", allMessages.length);

  await saveRollingSummary(
    env,
    user,
    dreamId,
    blockId,
    updatedSummary,
    allMessages.length,
    artworkId
  );

  console.log("[updateRollingSummary] DONE");
  return updatedSummary;
}

async function getUnprocessedMessages(env, user, dreamId, blockId, artworkId = null) {
  // 1) –ë–µ—Ä—ë–º –∑–∞–ø–∏—Å–∞–Ω–Ω–æ–µ summary
  let summarySql = `
    SELECT summary, last_message_count
    FROM dialog_summaries
    WHERE user = ? AND dream_id = ? AND block_id = ?
  `;
  const summaryParams = [user, dreamId, blockId];

  if (artworkId) {
    summarySql += ` AND artwork_id = ?`;
    summaryParams.push(artworkId);
  }

  const summaryRow = await env.DB.prepare(summarySql).bind(...summaryParams).first();
  const lastProcessed = summaryRow?.last_message_count || 0;

  // 2) –ë–µ—Ä—ë–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è
  let msgSql = `
    SELECT role, content
    FROM messages
    WHERE user = ? AND dream_id = ? AND block_id = ?
  `;
  const msgParams = [user, dreamId, blockId];

  if (artworkId) {
    msgSql += ` AND artwork_id = ?`;
    msgParams.push(artworkId);
  }

  msgSql += ` ORDER BY created_at ASC`;

  const unprocessedRows = await env.DB.prepare(msgSql).bind(...msgParams).all();
  const allMessages = unprocessedRows.results || [];
  const unprocessed = allMessages.slice(lastProcessed);

  return {
    rollingSummary: summaryRow?.summary || "",
    unprocessedMessages: unprocessed,
    totalCount: allMessages.length,
  };
}

async function toggleMessageArtworkInsight(env, { dreamId, messageId, liked, userEmail }) {
  const statement = env.DB.prepare(`
    UPDATE messages
    SET meta = json_set(COALESCE(meta, '{}'), '$.insightArtworksLiked', ?)
    WHERE id = ? AND dream_id = ? AND user = ?
  `);

  const { success } = await statement.bind(liked ? 1 : 0, messageId, dreamId, userEmail).run();
  if (!success) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∏–Ω—Å–∞–π—Ç –ø–æ artwork');

  const { results } = await env.DB
    .prepare(`
      SELECT id, role, content, meta, created_at
      FROM messages
      WHERE id = ? AND dream_id = ? AND user = ?
    `)
    .bind(messageId, dreamId, userEmail)
    .all();

  return results?.[0] ?? null;
}

async function toggleMessageInsight(env, { dreamId, messageId, liked, userEmail }) {
  const statement = env.DB.prepare(`
    UPDATE messages
    SET meta = json_set(COALESCE(meta, '{}'), '$.insightLiked', ?)
    WHERE id = ? AND dream_id = ? AND user = ?
  `);

  const { success } = await statement.bind(liked ? 1 : 0, messageId, dreamId, userEmail).run();
  if (!success) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∏–Ω—Å–∞–π—Ç');

  const { results } = await env.DB
    .prepare(`
      SELECT id, role, content, meta, created_at
      FROM messages
      WHERE id = ? AND dream_id = ? AND user = ?
    `)
    .bind(messageId, dreamId, userEmail)
    .all();

  return results?.[0] ?? null;
}

// --- INTERPRETATION FUNCTIONS ---

async function interpretBlock(env, blockText, blockType = 'dialog') {
  let systemPrompt;
  if (blockType === 'art') {
    systemPrompt = ART_BLOCK_INTERPRETATION_PROMPT;
  } else {
    systemPrompt = BLOCK_INTERPRETATION_PROMPT_DAILY;
  }

  const deepseekRequestBody = {
    model: 'deepseek-chat',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: blockText }
    ],
    max_tokens: 500,
    temperature: 0.5,
    stream: false
  };

  const res = await fetch('https://api.deepseek.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${env.DEEPSEEK_API_KEY}`
    },
    body: JSON.stringify(deepseekRequestBody)
  });

  const json = await res.json();
  let content = json.choices?.[0]?.message?.content || '';

  content = content.replace(/```[\s\S]*?```/g, '').trim();

  if (blockType === 'art') {
    let cleaned = content
      .replace(/```json\s*/gi, '')
      .replace(/```\s*$/g, '')
      .trim();

    try {
      return JSON.parse(cleaned);
    } catch {
      return {};
    }
  }
  content = content.replace(/^["'`]+|["'`]+$/g, '').trim();
  return content;
}

async function interpretFinal(env, notesText, blockType = 'dialog') {
  let prompt;
  if (blockType === 'art') {
    prompt = ART_FINAL_INTERPRETATION_PROMPT;
  } else {
    prompt = FINAL_INTERPRETATION_PROMPT_DAILY;
  }

  const deepseekRequestBody = {
    model: 'deepseek-chat',
    messages: [
      { role: 'system', content: prompt },
      { role: 'user', content: notesText }
    ],
    max_tokens: 800,
    temperature: 0.7,
    stream: false
  };

  const res = await fetch('https://api.deepseek.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${env.DEEPSEEK_API_KEY}`
    },
    body: JSON.stringify(deepseekRequestBody)
  });

  const json = await res.json();
  let content = json.choices?.[0]?.message?.content || '{}';
  content = content.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();

  try {
    return JSON.parse(content);
  } catch {
    return {};
  }
}

// --- HELPERS FOR DAILY CONVOS INSIGHTS ---
// –í—Å—Ç–∞–≤–∏—Ç—å —Ä—è–¥–æ–º —Å toggleMessageInsight/toggleMessageArtworkInsight

async function toggleDailyMessageInsight(env, { dailyConvoId, messageId, liked, userEmail }) {
  const statement = env.DB.prepare(`
    UPDATE messages
    SET meta = json_set(COALESCE(meta, '{}'), '$.insightLiked', ?)
    WHERE id = ? AND dream_id = ? AND user = ?
  `);

  const { success } = await statement.bind(liked ? 1 : 0, messageId, dailyConvoId, userEmail).run();
  if (!success) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∏–Ω—Å–∞–π—Ç (daily)');
  const { results } = await env.DB.prepare(`
    SELECT id, role, content, meta, created_at
    FROM messages
    WHERE id = ? AND dream_id = ? AND user = ?
  `).bind(messageId, dailyConvoId, userEmail).all();

  return results?.[0] ?? null;
}

async function toggleDailyMessageArtworkInsight(env, { dailyConvoId, messageId, liked, userEmail }) {
  const statement = env.DB.prepare(`
    UPDATE messages
    SET meta = json_set(COALESCE(meta, '{}'), '$.insightArtworksLiked', ?)
    WHERE id = ? AND dream_id = ? AND user = ?
  `);

  const { success } = await statement.bind(liked ? 1 : 0, messageId, dailyConvoId, userEmail).run();
  if (!success) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∞—Ä—Ç-–∏–Ω—Å–∞–π—Ç (daily)');
  const { results } = await env.DB.prepare(`
    SELECT id, role, content, meta, created_at
    FROM messages
    WHERE id = ? AND dream_id = ? AND user = ?
  `).bind(messageId, dailyConvoId, userEmail).all();

  return results?.[0] ?? null;
}

// --- –ú–∞–ø–ø–∏–Ω–≥ —Å—Ç–∞—Ä—ã—Ö —Å–Ω–æ–≤ –∫ –Ω–æ–≤–æ–º—É —Ñ–æ—Ä–º–∞—Ç—É ---
function normalizeDream(d) {
  if (d.text && !d.dreamText) d.dreamText = d.text;
  if (d.created && !d.date) d.date = d.created;
  if (d.updated && !d.date) d.date = d.updated;
  if (!d.blocks) d.blocks = [];
  if (!('globalFinalInterpretation' in d)) d.globalFinalInterpretation = null;
  if (!('dreamSummary' in d)) d.dreamSummary = null;
  if (!('category' in d)) d.category = null;
  if (!('context' in d)) d.context = '';
  if (!d.similarArtworks) d.similarArtworks = [];
  return d;
}

// --- –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö —Å–Ω–∞ ---
function validateDreamData(data) {
  if (!data) return { valid: false, error: 'Missing dream data' };
  if (typeof data.dreamText !== 'string' || data.dreamText.trim() === '') {
    return { valid: false, error: 'dreamText is required and must be a non-empty string' };
  }
  if (data.title && typeof data.title !== 'string') {
    return { valid: false, error: 'title must be a string' };
  }
  if (data.blocks && !Array.isArray(data.blocks)) {
    return { valid: false, error: 'blocks must be an array' };
  }
  if (data.similarArtworks && !Array.isArray(data.similarArtworks)) {
    return { valid: false, error: 'similarArtworks must be an array' };
  }
  return { valid: true };
}

// ===== Avatar helpers (–≤—Å—Ç–∞–≤–∏—Ç—å –ø–µ—Ä–µ–¥ export default) =====
const avatar_ALLOWED_TYPES = ['image/png', 'image/jpeg', 'image/webp'];
const avatar_MAX_SIZE = 2 * 1024 * 1024; // 2 MB
const avatar_ALLOWED_ICONS = VALID_AVATAR_ICONS || []; // fallback –Ω–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Å–ø–∏—Å–æ–∫

function avatar_buildCorsHeaders(request) {
  const origin = request.headers.get('Origin') || '';
  return buildCorsHeaders(origin);
}

async function avatar_extractEmailFromBearer(request, env) {
  const auth = request.headers.get('authorization');
  if (!auth || !auth.startsWith('Bearer ')) return null;
  const token = auth.slice(7);
  const payload = await verifyToken(token, env.JWT_SECRET);
  if (!payload?.email) return null;

  // Validate tokenVersion against USERS_KV (–∫–∞–∫ –≤ getUserEmail)
  try {
    const userRaw = await env.USERS_KV.get(`user:${payload.email}`);
    if (!userRaw) return null;
    const user = JSON.parse(userRaw);
    const currentTv = user.tokenVersion ?? 0;
    if (typeof payload.tv !== 'number' || payload.tv !== currentTv) return null;
    return payload.email;
  } catch (e) {
    console.warn('avatar_extractEmailFromBearer error:', e);
    return null;
  }
}

function avatar_generateKey(userEmail, fileType) {
  const ext = (fileType.split('/')[1] || 'png').replace(/[^a-z0-9]/gi, '').toLowerCase();
  const ts = Date.now();
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º UUID + —á–∞—Å—Ç—å —Ä–∞–Ω–¥–æ–º–∞ –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏
  const uuid = (crypto && crypto.randomUUID) ? crypto.randomUUID() : `${ts}-${Math.random().toString(36).slice(2,10)}`;
  // –ù–ï –¥–æ–±–∞–≤–ª—è–µ–º –ø—Ä–µ—Ñ–∏–∫—Å 'avatars/' –≤ —Å–∞–º –∫–ª—é—á ‚Äî –∫–ª—é—á –±—É–¥–µ—Ç —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å —Ç–µ–º, —á—Ç–æ –æ–∂–∏–¥–∞–µ—Ç /avatars/:key
  return `${encodeURIComponent(userEmail)}-${ts}-${uuid}.${ext}`;
}

async function avatar_handleUpload(request, env) {
  const corsHeaders = avatar_buildCorsHeaders(request);

  const userEmail = await avatar_extractEmailFromBearer(request, env);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized', message: 'Invalid or missing token' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const ct = request.headers.get('content-type') || '';
  if (!ct.includes('multipart/form-data')) {
    return new Response(JSON.stringify({ error: 'invalid_content_type', message: 'Expected multipart/form-data' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  let form;
  try {
    form = await request.formData();
  } catch (e) {
    return new Response(JSON.stringify({ error: 'invalid_form', message: 'Cannot parse form-data' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const file = form.get('file');
  if (!file || !(file instanceof Blob)) {
    return new Response(JSON.stringify({ error: 'no_file', message: 'field "file" is required' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  if (!avatar_ALLOWED_TYPES.includes(file.type)) {
    return new Response(JSON.stringify({ error: 'unsupported_file_type', message: `Allowed: ${avatar_ALLOWED_TYPES.join(', ')}` }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  if (file.size > avatar_MAX_SIZE) {
    return new Response(JSON.stringify({ error: 'file_too_large', message: 'Max 2MB' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ë–î (–¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Å—Ç–∞—Ä–æ–≥–æ –∞–≤–∞—Ç–∞—Ä–∞)
    const curRow = await env.DB.prepare('SELECT avatar_image_url FROM users WHERE email = ?').bind(userEmail).first();
    if (curRow && curRow.avatar_image_url) {
      try {
        const oldUrl = curRow.avatar_image_url;
        try {
          const parsed = new URL(oldUrl);
          const oldKey = parsed.pathname.replace(/^\/avatars\//, '');
          if (oldKey) {
            await env.AVATARS.delete(oldKey);
          }
        } catch (e) {
          // –µ—Å–ª–∏ oldUrl –Ω–µ –ø–∞—Ä—Å–∏—Ç—Å—è ‚Äî –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
          console.warn('avatar_handleUpload: could not parse old avatar url', e);
        }
      } catch (e) {
        console.warn('avatar_handleUpload: failed to delete old avatar (ignored)', e);
      }
    }

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–∞ –∏ –∑–∞–ª–∏–≤–∫–∞
    const key = avatar_generateKey(userEmail, file.type); // –ù–ï —Å–æ–¥–µ—Ä–∂–∏—Ç 'avatars/' –ø—Ä–µ—Ñ–∏–∫—Å–∞
    await env.AVATARS.put(key, file.stream(), {
      httpMetadata: { contentType: file.type }
    });

    const origin = new URL(request.url).origin;
    const publicUrl = `${origin}/avatars/${encodeURIComponent(key)}`;

    // –û–±–Ω–æ–≤–ª—è–µ–º users.avatar_image_url –≤ DB
    await env.DB.prepare('UPDATE users SET avatar_image_url = ? WHERE email = ?').bind(publicUrl, userEmail).run();

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—É—é –∑–∞–ø–∏—Å—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const updatedUser = await env.DB.prepare(
      'SELECT id, email, name, avatar_icon, avatar_image_url, created_at FROM users WHERE email = ?'
    ).bind(userEmail).first();

    return new Response(JSON.stringify({ ok: true, user: updatedUser }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (e) {
    console.error('avatar_handleUpload error:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || 'Upload failed' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

async function avatar_handleServe(request, env) {
  const corsHeaders = avatar_buildCorsHeaders(request);
  const pathname = new URL(request.url).pathname;
  const key = pathname.replace(/^\/avatars\//, '');
  if (!key) {
    return new Response('Not Found', { status: 404, headers: { ...corsHeaders } });
  }

  try {
    const object = await env.AVATARS.get(decodeURIComponent(key));
    if (!object) {
      return new Response('Not Found', { status: 404, headers: { ...corsHeaders } });
    }

    const headers = new Headers();
    headers.set('Content-Type', object.httpMetadata?.contentType || 'application/octet-stream');
    headers.set('Cache-Control', 'public, max-age=3600, s-maxage=86400');
    // merge cors headers (buildCorsHeaders returns plain object)
    Object.entries(avatar_buildCorsHeaders(request)).forEach(([k, v]) => headers.set(k, v));

    // object.body is a ReadableStream
    return new Response(object.body, { status: 200, headers });
  } catch (e) {
    console.error('avatar_handleServe error:', e);
    return new Response('Internal Error', { status: 500, headers: { ...corsHeaders } });
  }
}
// ===== end Avatar helpers =====

async function getOrCreateUserRowByEmail(env, email) {
  if (!email) {
    console.warn('[getOrCreateUserRowByEmail] email is empty');
    return null;
  }

  // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è email
  email = email.trim().toLowerCase();
  console.log('[getOrCreateUserRowByEmail] Normalized email:', email);

  // 1) –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –≤ D1
  let row = await env.DB
    .prepare('SELECT id, email, password_hash, created_at FROM users WHERE LOWER(email) = ?')
    .bind(email)
    .first();

  console.log('[getOrCreateUserRowByEmail] D1 row:', row);

  if (row && row.id) {
    return row;
  }

  // 2) –µ—Å–ª–∏ –Ω–µ—Ç ‚Äî –¥–æ—Å—Ç–∞—ë–º –∏–∑ KV
  const userRaw = await env.USERS_KV.get(`user:${email}`);
  console.log('[getOrCreateUserRowByEmail] KV lookup:', userRaw ? 'found' : 'NOT FOUND');

  if (!userRaw) {
    console.warn('[getOrCreateUserRowByEmail] User not in KV:', email);
    return null;
  }

  let kv;
  try {
    kv = JSON.parse(userRaw);
  } catch (e) {
    console.error('[getOrCreateUserRowByEmail] KV parse error:', e);
    kv = {};
  }

  const password_hash = kv.password ?? '';
  const createdMs = kv.created ?? Date.now();
  const created_at = new Date(createdMs).toISOString();

  // üÜï –ì–µ–Ω–µ—Ä–∞—Ü–∏—è UUID
  const id = crypto.randomUUID();

  console.log('[getOrCreateUserRowByEmail] Attempting insert:', { id, email });

  // 3) —Å–æ–∑–¥–∞—ë–º –∑–∞–ø–∏—Å—å –≤ D1
  try {
    await env.DB.prepare(
      `INSERT INTO users (id, email, password_hash, name, avatar_icon, avatar_image_url, created_at)
       VALUES (?, ?, ?, NULL, NULL, NULL, ?)`
    )
      .bind(id, email, password_hash, created_at)
      .run();

    console.log('[getOrCreateUserRowByEmail] Insert successful');
  } catch (e) {
    console.error('[getOrCreateUserRowByEmail] Insert error:', e);
    const msg = String(e?.message || e);
    if (!msg.includes('UNIQUE constraint failed: users.email')) {
      throw e;
    }
    console.log('[getOrCreateUserRowByEmail] UNIQUE conflict, will re-read');
  }

  // 4) –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—É—é —Å—Ç—Ä–æ–∫—É –∏–∑ D1
  row = await env.DB
    .prepare('SELECT id, email, password_hash, created_at FROM users WHERE LOWER(email) = ?')
    .bind(email)
    .first();

  console.log('[getOrCreateUserRowByEmail] Final row:', row);

  if (!row || !row.id) {
    console.error('[getOrCreateUserRowByEmail] CRITICAL: Failed to create/retrieve user');
    return null;
  }

  return row;
}

// ----------------------------
// Subscription helpers
// ----------------------------
async function getVisiblePlans(env) {
  const res = await env.DB.prepare(
    `SELECT id, plan_code, title, description, price, emoji, visible, created_at, updated_at
     FROM subscription_plans
     WHERE visible = 1
     ORDER BY CAST(price AS REAL) ASC`
  ).all();
  return (res?.results || []);
}

async function createSubscriptionChoice(env, userEmail, payload = {}) {
  // payload: { plan_id, plan_code, chosen_emoji, chosen_price, is_custom_price, trial_days_left, source, notes }
  const id = crypto.randomUUID();
  const now = Date.now();

  const {
    plan_id = null,
    plan_code = null,
    chosen_emoji = null,
    chosen_price = null,
    is_custom_price = 0,
    trial_days_left = null,
    source = null,
    notes = null
  } = payload;

  await env.DB.prepare(`
    INSERT INTO user_subscription_choices
      (id, user_id, plan_id, plan_code, chosen_emoji, chosen_price, is_custom_price, trial_days_left, modal_open_count, selection_count, confirmed_purchase, purchase_timestamp, purchase_amount, source, notes, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).bind(
    id,
    userEmail,
    plan_id,
    plan_code,
    chosen_emoji,
    chosen_price,
    is_custom_price ? 1 : 0,
    trial_days_left,
    0,    // modal_open_count
    1,    // selection_count (first selection)
    0,    // confirmed_purchase
    null, // purchase_timestamp
    null, // purchase_amount
    source,
    notes,
    now,
    now
  ).run();

  const row = await env.DB.prepare('SELECT * FROM user_subscription_choices WHERE id = ?').bind(id).first();
  return row ?? null;
}

async function incrementModalOpenCount(env, userEmail, opts = {}) {
  // opts: { choice_id } -- –µ—Å–ª–∏ –µ—Å—Ç—å, –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∏–º —Ç—É –∑–∞–ø–∏—Å—å; –∏–Ω–∞—á–µ —Å–æ–∑–¥–∞—ë–º lightweight –∑–∞–ø–∏—Å—å "modal_open"
  if (opts.choice_id) {
    const res = await env.DB.prepare(`
      UPDATE user_subscription_choices
      SET modal_open_count = COALESCE(modal_open_count, 0) + 1, updated_at = ?
      WHERE id = ? AND user_id = ?
    `).bind(Date.now(), opts.choice_id, userEmail).run();
    return res;
  } else {
    const id = crypto.randomUUID();
    const now = Date.now();
    await env.DB.prepare(`
      INSERT INTO user_subscription_choices
        (id, user_id, plan_id, plan_code, chosen_emoji, chosen_price, is_custom_price, trial_days_left, modal_open_count, selection_count, confirmed_purchase, purchase_timestamp, purchase_amount, source, notes, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      id,
      userEmail,
      null,
      'modal_open',
      null,
      null,
      0,
      null,
      1,   // modal_open_count
      0,   // selection_count
      0,   // confirmed_purchase
      null,
      null,
      'modal', // source
      null,
      now,
      now
    ).run();
    const row = await env.DB.prepare('SELECT * FROM user_subscription_choices WHERE id = ?').bind(id).first();
    return row ?? null;
  }
}

async function confirmPurchaseForChoice(env, userEmail, choiceId, purchaseAmountText) {
  const ts = Date.now();
  const res = await env.DB.prepare(`
    UPDATE user_subscription_choices
    SET confirmed_purchase = 1, purchase_timestamp = ?, purchase_amount = ?, updated_at = ?
    WHERE id = ? AND user_id = ?
  `).bind(ts, purchaseAmountText, ts, choiceId, userEmail).run();
  return res;
}

async function getUserSubscriptionChoices(env, userEmail, limit = 50) {
  const res = await env.DB.prepare(`
    SELECT * FROM user_subscription_choices
    WHERE user_id = ?
    ORDER BY created_at DESC
    LIMIT ?
  `).bind(userEmail, limit).all();
  return res?.results || [];
}

// ===== Personal goals helpers =====

async function getUserIdByEmail(env, email) {
  const row = await getOrCreateUserRowByEmail(env, email);
  return row?.id || null;
}

async function createGoal(env, userEmail, body) {
  const userId = await getUserIdByEmail(env, userEmail);
  if (!userId) throw new Error('User not found in DB');

  const id = crypto.randomUUID();
  const {
    title,
    description,
    category,
    goalType,
    targetCount,
    unit,
    period,
    startDate,
    dueDate
  } = body;

  await env.DB.prepare(
    `INSERT INTO personal_goals
     (id, user_id, title, description, category, goal_type, target_count, unit, period, start_date, due_date)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
  ).bind(
    id,
    userId,
    title,
    description ?? null,
    category ?? null,
    goalType,
    targetCount ?? null,
    unit ?? null,
    period ?? null,
    startDate,
    dueDate ?? null
  ).run();

  return { id };
}

async function getGoalsWithProgress(env, userEmail) {
  const userId = await getUserIdByEmail(env, userEmail);
  if (!userId) throw new Error('User not found in DB');

  const stmt = env.DB.prepare(
    `SELECT
       g.id          AS goal_id,
       g.title,
       g.description,
       g.category,
       g.goal_type,
       g.target_count,
       g.unit,
       g.period,
       g.start_date,
       g.due_date,
       g.status,
       g.created_at,
       g.updated_at,
       COALESCE(SUM(e.amount), 0) AS total_done,
       CASE
         WHEN g.target_count IS NOT NULL AND g.target_count > 0
           THEN ROUND(100.0 * COALESCE(SUM(e.amount), 0) / g.target_count, 1)
         ELSE NULL
       END AS progress_percent
     FROM personal_goals g
     LEFT JOIN personal_goal_events e
       ON e.goal_id = g.id
       AND e.user_id = g.user_id
     WHERE g.user_id = ?
     GROUP BY g.id
     ORDER BY g.created_at DESC`
  );

  const res = await stmt.bind(userId).all();
  return res.results ?? [];
}

async function addGoalEvent(env, userEmail, goalId, body) {
  const userId = await getUserIdByEmail(env, userEmail);
  if (!userId) throw new Error('User not found in DB');

  const amount = body.amount ?? 1;
  const eventDate = body.eventDate ?? Math.floor(Date.now() / 1000);

  await env.DB.prepare(
    `INSERT INTO personal_goal_events
     (goal_id, user_id, event_date, amount)
     VALUES (?, ?, ?, ?)`
  ).bind(goalId, userId, eventDate, amount).run();

  return { ok: true };
}

async function getGoalsTimeline(env, userEmail, range) {
  const now = Math.floor(Date.now() / 1000); // —Å–µ–∫—É–Ω–¥—ã
  let from;

  switch (range) {
    case '7d':
      from = now - 7 * 24 * 3600;
      break;
    case '30d':
      from = now - 30 * 24 * 3600;
      break;
    case '60d':
      from = now - 60 * 24 * 3600;
      break;
    case '90d':
      from = now - 90 * 24 * 3600;
      break;
    case '365d':
      from = now - 365 * 24 * 3600;
      break;
    case 'all':
    default:
      from = 0;
  }

  const userId = await getUserIdByEmail(env, userEmail);
  if (!userId) throw new Error('User not found in DB');

  const totalTargetRow = await env.DB
    .prepare(
      `SELECT COALESCE(SUM(target_count), 0) AS total_target
       FROM personal_goals
       WHERE user_id = ?
         AND (status IS NULL OR status != 'archived')`
    )
    .bind(userId)
    .first();

  const totalTarget = Number(totalTargetRow?.total_target || 0);

  const stmt = env.DB.prepare(
    `WITH daily AS (
       SELECT
         DATE(event_date, 'unixepoch') AS d,
         SUM(amount) AS daily_amount
       FROM personal_goal_events
       WHERE user_id = ?
         AND event_date BETWEEN ? AND ?
       GROUP BY DATE(event_date, 'unixepoch')
     ),
     cum AS (
       SELECT
         d,
         SUM(daily_amount) OVER (ORDER BY d) AS cumulative_amount
       FROM daily
     )
     SELECT d AS date, cumulative_amount
     FROM cum
     ORDER BY d`
  );

  const res = await stmt.bind(userId, from, now).all();
  const rows = res.results ?? [];

  if (totalTarget > 0) {
    return rows.map(r => ({
      date: r.date,
      cumulative_amount: r.cumulative_amount,
      percent: Math.max(
        0,
        Math.min(100, Math.round((r.cumulative_amount / totalTarget) * 100)),
      ),
    }));
  }

  return rows;
}

// ===== end Personal goals helpers =====

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // ‚úÖ 1. –û–ë–†–ê–ë–û–¢–ö–ê OPTIONS (PREFLIGHT) ‚Äî –ü–ï–†–í–´–ú –î–ï–õ–û–ú!
    if (request.method === 'OPTIONS') {
      const origin = request.headers.get('Origin') || '';
      const cors = buildCorsHeaders(origin);
      return new Response(null, { status: 204, headers: cors });
    }

    // ‚úÖ 2. –¢–µ–ø–µ—Ä—å buildCorsHeaders –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
    const origin = request.headers.get('Origin') || '';
    const corsHeaders = buildCorsHeaders(origin);
    const pathParts = url.pathname.split('/').filter(Boolean);

    const JWT_SECRET = env.JWT_SECRET;

    if (!JWT_SECRET) {
      console.error('JWT_SECRET is not set');
      return new Response(JSON.stringify({ error: 'server_misconfigured', message: 'JWT_SECRET is not set' }), {
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    if (url.pathname === '/health' && request.method === 'GET') {
      return new Response(JSON.stringify({ ok: true, ts: Date.now() }), {
        status: 200,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    // === PERSONAL GOALS API ===

    // GET /goals - —Å–ø–∏—Å–æ–∫ —Ü–µ–ª–µ–π —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º
    if (url.pathname === '/goals' && request.method === 'GET') {
      const userEmail = await getUserEmail(request);
      if (!userEmail) {
        return new Response(JSON.stringify({ error: 'unauthorized' }), {
          status: 401,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }

      try {
        const goals = await getGoalsWithProgress(env, userEmail);
        return new Response(JSON.stringify({ goals }), {
          status: 200,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (e) {
        console.error('GET /goals error', e);
        return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // POST /goals - —Å–æ–∑–¥–∞—Ç—å —Ü–µ–ª—å
    if (url.pathname === '/goals' && request.method === 'POST') {
      const userEmail = await getUserEmail(request);
      if (!userEmail) {
        return new Response(JSON.stringify({ error: 'unauthorized' }), {
          status: 401,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }

      const ct = request.headers.get('content-type') || '';
      if (!ct.includes('application/json')) {
        return new Response(JSON.stringify({ error: 'Invalid content type' }), {
          status: 400,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }

      let body;
      try {
        body = await request.json();
      } catch {
        return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
          status: 400,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }

      const { title, goalType, startDate } = body || {};
      if (!title || !goalType || !startDate) {
        return new Response(JSON.stringify({ error: 'title, goalType and startDate are required' }), {
          status: 400,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }

      try {
        const resCreate = await createGoal(env, userEmail, body);
        return new Response(JSON.stringify({ id: resCreate.id }), {
          status: 201,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (e) {
        console.error('POST /goals error', e);
        return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // POST /goals/:id/event - –¥–æ–±–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ (–°–¥–µ–ª–∞—Ç—å)
    if (request.method === 'POST' && pathParts.length === 3 && pathParts[0] === 'goals' && pathParts[2] === 'event') {
      const userEmail = await getUserEmail(request);
      if (!userEmail) {
        return new Response(JSON.stringify({ error: 'unauthorized' }), {
          status: 401,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }

      const goalId = pathParts[1];

      let body;
      try {
        body = await request.json();
      } catch {
        body = {};
      }

      try {
        const resAdd = await addGoalEvent(env, userEmail, goalId, body || {});
        return new Response(JSON.stringify(resAdd), {
          status: 200,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (e) {
        console.error('POST /goals/:id/event error', e);
        return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // PUT /goals/:id - –æ–±–Ω–æ–≤–∏—Ç—å —Ü–µ–ª—å (–≤–∫–ª—é—á–∞—è target_count)
if (request.method === 'PUT' && pathParts.length === 2 && pathParts[0] === 'goals') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const goalId = pathParts[1];

  let body;
  try {
    body = await request.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const userId = await getUserIdByEmail(env, userEmail);
  if (!userId) throw new Error('User not found in DB');

  const {
    title,
    description,
    category,
    targetCount,
    unit,
    period,
    dueDate,
    status
  } = body;

  try {
    const sets = [];
    const binds = [];

    if (typeof title !== 'undefined') { sets.push('title = ?'); binds.push(title); }
    if (typeof description !== 'undefined') { sets.push('description = ?'); binds.push(description); }
    if (typeof category !== 'undefined') { sets.push('category = ?'); binds.push(category); }
    if (typeof targetCount !== 'undefined') { sets.push('target_count = ?'); binds.push(targetCount); }
    if (typeof unit !== 'undefined') { sets.push('unit = ?'); binds.push(unit); }
    if (typeof period !== 'undefined') { sets.push('period = ?'); binds.push(period); }
    if (typeof dueDate !== 'undefined') { sets.push('due_date = ?'); binds.push(dueDate); }
    if (typeof status !== 'undefined') { sets.push('status = ?'); binds.push(status); }

    sets.push('updated_at = ?'); // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
    binds.push(Date.now());      // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û

    binds.push(goalId, userId);

    const sql = `UPDATE personal_goals SET ${sets.join(', ')} WHERE id = ? AND user_id = ?`;
    await env.DB.prepare(sql).bind(...binds).run();

    return new Response(JSON.stringify({ ok: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('PUT /goals/:id error', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// DELETE /goals/:id - —É–¥–∞–ª–∏—Ç—å —Ü–µ–ª—å
if (request.method === 'DELETE' && pathParts.length === 2 && pathParts[0] === 'goals') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const goalId = pathParts[1];

  try {
    const userId = await getUserIdByEmail(env, userEmail);
    if (!userId) throw new Error('User not found in DB');

    // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–æ–±—ã—Ç–∏—è —Ü–µ–ª–∏
    await env.DB.prepare(
      'DELETE FROM personal_goal_events WHERE goal_id = ? AND user_id = ?'
    ).bind(goalId, userId).run();

    // –£–¥–∞–ª—è–µ–º —Å–∞–º—É —Ü–µ–ª—å
    const res = await env.DB.prepare(
      'DELETE FROM personal_goals WHERE id = ? AND user_id = ?'
    ).bind(goalId, userId).run();

    if (res.changes === 0) {
      return new Response(JSON.stringify({ error: 'Goal not found' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    return new Response(JSON.stringify({ ok: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('DELETE /goals/:id error', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

    // GET /goals/timeline?range=7d
    if (url.pathname === '/goals/timeline' && request.method === 'GET') {
      const userEmail = await getUserEmail(request);
      if (!userEmail) {
        return new Response(JSON.stringify({ error: 'unauthorized' }), {
          status: 401,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }

      const range = url.searchParams.get('range') || '30d';

      try {
        const points = await getGoalsTimeline(env, userEmail, range);
        return new Response(JSON.stringify({ points }), {
          status: 200,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (e) {
        console.error('GET /goals/timeline error', e);
        return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/register' && request.method === 'POST') {
      const ct = request.headers.get('content-type') || '';
      if (!ct.includes('application/json')) {
        return new Response(JSON.stringify({ error: 'Invalid content type' }), {
          status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      let body;
      try {
        body = await request.json();
      } catch {
        return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
          status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      const { email, password } = body;
      if (!email || !password) {
        return new Response(JSON.stringify({ error: 'Missing email or password' }), {
          status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      const userKey = `user:${email}`;
      const existing = await env.USERS_KV.get(userKey);
      if (existing) {
        return new Response(JSON.stringify({ error: 'User already exists' }), {
          status: 409, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      try {
        const hash = await hashPassword(password);
        const user = { email, password: hash, created: Date.now(), tokenVersion: 0 };
        await env.USERS_KV.put(userKey, JSON.stringify(user));
        return new Response(JSON.stringify({ success: true }), {
          status: 201, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (e) {
        console.error('Error during registration:', e);
        return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
          status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/login' && request.method === 'POST') {
      const ct = request.headers.get('content-type') || '';
      if (!ct.includes('application/json')) {
        return new Response(JSON.stringify({ error: 'Invalid content type' }), {
          status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      let body;
      try {
        body = await request.json();
      } catch {
        return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
          status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      const { email, password } = body;
      if (!email || !password) {
        return new Response(JSON.stringify({ error: 'Missing email or password' }), {
          status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      const userKey = `user:${email}`;
      const userRaw = await env.USERS_KV.get(userKey);
      if (!userRaw) {
        return new Response(JSON.stringify({ error: 'User not found' }), {
          status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      let user;
      try {
        user = JSON.parse(userRaw);
      } catch {
        return new Response(JSON.stringify({ error: 'User data corrupted' }), {
          status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      try {
        const hash = await hashPassword(password);
        if (user.password !== hash) {
          return new Response(JSON.stringify({ error: 'Invalid password' }), {
            status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
      } catch (e) {
        console.error('Error hashing password:', e);
        return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
          status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      const now = Date.now();
      const trialPeriod = 365 * 24 * 60 * 60 * 1000;
      if (now - user.created > trialPeriod) {
        return new Response(JSON.stringify({ error: 'Trial expired' }), {
          status: 403, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      const tokenVersion = user.tokenVersion ?? 0;
      const payload = { email, iat: Date.now(), exp: Date.now() + 7 * 24 * 60 * 60 * 1000, tv: tokenVersion };
      const token = await createToken(payload, JWT_SECRET);
      return new Response(JSON.stringify({ token }), {
        status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    async function getUserEmail(request) {
      const auth = request.headers.get('authorization');
      if (!auth || !auth.startsWith('Bearer ')) return null;
      const token = auth.slice(7);
      const payload = await verifyToken(token, JWT_SECRET);
      if (!payload?.email) return null;
      const userRaw = await env.USERS_KV.get(`user:${payload.email}`);
      if (!userRaw) return null;
      let user;
      try {
        user = JSON.parse(userRaw);
      } catch {
        return null;
      }
      const currentTv = user.tokenVersion ?? 0;
      if (typeof payload.tv !== 'number' || payload.tv !== currentTv) return null;
      return payload.email;
    }

    // --- GET /me (–∑–∞–º–µ–Ω–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –±–ª–æ–∫) ---
if (url.pathname === '/me' && request.method === 'GET') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  // –ë–µ—Ä—ë–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∏–∑ KV (—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è, password –∏ —Ç.–¥.)
  const userRaw = await env.USERS_KV.get(`user:${userEmail}`);
  if (!userRaw) {
    return new Response(JSON.stringify({ error: 'User not found' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  let kvUser = {};
  try { kvUser = JSON.parse(userRaw); } catch (e) { kvUser = {}; }

  // –ë–µ—Ä—ë–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –∏–∑ D1 (–µ—Å–ª–∏ –µ—Å—Ç—å)
  const userRow = await env.DB.prepare(
    'SELECT name, avatar_icon, avatar_image_url, created_at FROM users WHERE email = ?'
  ).bind(userEmail).first();

  const name = userRow?.name ?? kvUser.name ?? null;
  const avatar_icon = userRow?.avatar_icon ?? kvUser.avatar_icon ?? null;
  const avatar_image_url = userRow?.avatar_image_url ?? kvUser.avatar_image_url ?? null;

  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º created timestamp (KV —Ö—Ä–∞–Ω–∏—Ç ms number, D1 –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å ISO)
  const createdSrc = kvUser.created ?? userRow?.created_at ?? Date.now();
  const created = typeof createdSrc === 'number' ? createdSrc : (new Date(createdSrc).getTime() || Date.now());

  const now = Date.now();
  const trialPeriod = 365 * 24 * 60 * 60 * 1000;
  const msLeft = (created || now) + trialPeriod - now;
  const daysLeft = Math.ceil(msLeft / (24 * 60 * 60 * 1000));

  // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –ø–æ–¥–ø–∏—Å–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ user_subscription_choices –∏ subscription_plans
  const subscriptionChoice = await env.DB.prepare(`
    SELECT usc.plan_id, sp.title, sp.emoji, sp.price
    FROM user_subscription_choices usc
    LEFT JOIN subscription_plans sp ON sp.id = usc.plan_id
    WHERE usc.user_id = ?
    ORDER BY usc.created_at DESC
    LIMIT 1
  `).bind(userEmail).first();

  const subscription_plan_id = subscriptionChoice?.plan_id ?? null;
  const subscription_plan_title = subscriptionChoice?.title ?? null;
  const subscription = subscriptionChoice ? {
    id: subscriptionChoice.plan_id,
    title: subscriptionChoice.title,
    emoji: subscriptionChoice.emoji,
    price: subscriptionChoice.price,
  } : null;

  return new Response(JSON.stringify({
    email: userEmail,
    created,
    trialEndsAt: (created || now) + trialPeriod,
    trialDaysLeft: daysLeft,
    name,
    avatar_icon,
    avatarIcon: avatar_icon,             // alias –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
    avatar_image_url,
    avatarImageUrl: avatar_image_url,   // alias
    subscription_plan_id,
    subscription_plan_title,
    subscription,
  }), {
    status: 200,
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
}

// ----------------------------
// SUBSCRIPTION API
// ----------------------------

// GET /plans
if (url.pathname === '/plans' && request.method === 'GET') {
  try {
    const plans = await getVisiblePlans(env);
    return new Response(JSON.stringify({ plans }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('GET /plans error', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// POST /subscription/choice
if (url.pathname === '/subscription/choice' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const ct = request.headers.get('content-type') || '';
  if (!ct.includes('application/json')) {
    return new Response(JSON.stringify({ error: 'Invalid content type' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  let body;
  try { body = await request.json(); } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    // expected body: { plan_id, plan_code, chosen_emoji, chosen_price, is_custom_price, trial_days_left, source, notes }
    const choice = await createSubscriptionChoice(env, userEmail, body || {});
    return new Response(JSON.stringify({ ok: true, choice }), {
      status: 201,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('POST /subscription/choice error', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// POST /subscription/modal-open
if (url.pathname === '/subscription/modal-open' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  let body = {};
  try { body = await request.json(); } catch { body = {}; }

  try {
    const row = await incrementModalOpenCount(env, userEmail, { choice_id: body?.choice_id || null });
    return new Response(JSON.stringify({ ok: true, row }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('POST /subscription/modal-open error', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// POST /subscription/confirm
if (url.pathname === '/subscription/confirm' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  let body = {};
  try { body = await request.json(); } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), { status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders } });
  }

  const { choiceId, purchaseAmount } = body || {};
  if (!choiceId) {
    return new Response(JSON.stringify({ error: 'choiceId required' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    await confirmPurchaseForChoice(env, userEmail, choiceId, purchaseAmount ?? null);
    return new Response(JSON.stringify({ ok: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('POST /subscription/confirm error', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// GET /subscription/choices
if (url.pathname === '/subscription/choices' && request.method === 'GET') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const choices = await getUserSubscriptionChoices(env, userEmail, 50);
    return new Response(JSON.stringify({ choices }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('GET /subscription/choices error', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- MOODS API (multi-user) ---

    // –ü–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –∑–∞ –¥–µ–Ω—å
    if (url.pathname.endsWith('/moods') && request.method === 'GET') {
      const userEmail = await getUserEmail(request);
      if (!userEmail) {
        return new Response(JSON.stringify({ error: 'unauthorized' }), {
          status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      const date = url.searchParams.get('date');
      if (!date) {
        return new Response(JSON.stringify({ error: 'date required' }), {
          status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      try {
        const row = await env.DB.prepare(
          'SELECT context FROM moods WHERE user_email = ? AND date = ?'
        ).bind(userEmail, date).first();
        return new Response(JSON.stringify({ context: row?.context ?? null }), {
          status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (e) {
        console.error('[MOODS] GET error:', e);
        return new Response(JSON.stringify({ error: 'database_error' }), {
          status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å/–æ–±–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –∑–∞ –¥–µ–Ω—å
    if (url.pathname.endsWith('/moods') && request.method === 'PUT') {
      const userEmail = await getUserEmail(request);
      if (!userEmail) {
        return new Response(JSON.stringify({ error: 'unauthorized' }), {
          status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      let body;
      try { body = await request.json(); } catch {
        return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
          status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      const { date, context } = body;
      if (!date || !context) {
        return new Response(JSON.stringify({ error: 'date and context required' }), {
          status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      try {
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º INSERT OR REPLACE –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
        await env.DB.prepare(
          `INSERT OR REPLACE INTO moods (user_email, date, context, updated_at) 
           VALUES (?, ?, ?, CURRENT_TIMESTAMP)`
        ).bind(userEmail, date, context).run();
        return new Response(JSON.stringify({ success: true }), {
          status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (e) {
        console.error('[MOODS] PUT error:', e);
        return new Response(JSON.stringify({ error: 'database_error' }), {
          status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –∑–∞ –º–µ—Å—è—Ü
    if (url.pathname.endsWith('/moods/month') && request.method === 'GET') {
      const userEmail = await getUserEmail(request);
      if (!userEmail) {
        return new Response(JSON.stringify({ error: 'unauthorized' }), {
          status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      const year = url.searchParams.get('year');
      const month = url.searchParams.get('month');
      if (!year || !month) {
        return new Response(JSON.stringify({ error: 'year and month required' }), {
          status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      try {
        const monthStr = String(month).padStart(2, '0');
        const rows = await env.DB.prepare(
          'SELECT date, context FROM moods WHERE user_email = ? AND date LIKE ?'
        ).bind(userEmail, `${year}-${monthStr}-%`).all();
        return new Response(JSON.stringify({ moods: rows.results }), {
          status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (e) {
        console.error('[MOODS] GET /month error:', e);
        return new Response(JSON.stringify({ error: 'database_error' }), {
          status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // --- DREAMS API with D1 integration ---

if (url.pathname === '/dreams' && request.method === 'GET') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  if (!(await isTrialActive(userEmail, env))) {
    return new Response(JSON.stringify({ error: 'Trial expired' }), {
      status: 403,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const d1 = env.DB;
    const result = await d1
      .prepare('SELECT * FROM dreams WHERE user = ? ORDER BY date DESC')
      .bind(userEmail)
      .all();

    const dreams = await Promise.all(
      result.results.map(async (row) => {
        // –ü–∞—Ä—Å–∏–º blocks
        if (row.blocks) {
          try {
            row.blocks = JSON.parse(row.blocks);
          } catch {
            row.blocks = [];
          }
        } else {
          row.blocks = [];
        }

        // –ó–∞–≥—Ä—É–∂–∞–µ–º similarArtworks –∏–∑ dream_similar_artworks + artworks
        const similarRes = await d1.prepare(`
          SELECT
            a.id AS artworkId,
            a.title,
            a.author,
            a.desc,
            a.value,
            a.type,
            dsa.position AS rank
          FROM dream_similar_artworks dsa
          JOIN artworks a ON dsa.artwork_id = a.id
          WHERE dsa.dream_id = ?
          ORDER BY dsa.position ASC
        `).bind(row.id).all();

        row.similarArtworks = (similarRes.results || []).map((art) => ({
          artworkId: art.artworkId,
          title: art.title,
          author: art.author,
          desc: art.desc,
          value: art.value,
          type: art.type,
          rank: art.rank,
          imageUrl: art.value, // –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        }));

        return normalizeDream(row);
      })
    );

    return new Response(JSON.stringify(dreams), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('Error fetching dreams:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

if (url.pathname === '/dreams' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  if (!(await isTrialActive(userEmail, env))) {
    return new Response(JSON.stringify({ error: 'Trial expired' }), {
      status: 403,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  let body;
  try {
    body = await request.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const validation = validateDreamData(body);
  if (!validation.valid) {
    return new Response(JSON.stringify({ error: 'Invalid dream data', message: validation.error }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const { dreamText } = body;
  const id = crypto.randomUUID();
  const date = Date.now();

  try {
    const d1 = env.DB;
    await d1.prepare(
      `INSERT INTO dreams (id, user, title, dreamText, date, category, dreamSummary, globalFinalInterpretation, blocks, similarArtworks, context)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
    ).bind(
      id,
      userEmail,
      null,
      dreamText.trim(),
      date,
      null,
      null,
      null,
      JSON.stringify([]),
      JSON.stringify([]), // –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
      null
    ).run();

    const dream = {
      id,
      user: userEmail,
      title: null,
      dreamText: dreamText.trim(),
      date,
      category: null,
      dreamSummary: null,
      globalFinalInterpretation: null,
      blocks: [],
      similarArtworks: [], // –±—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ –ø—Ä–∏ GET
      context: null
    };

    return new Response(JSON.stringify(dream), {
      status: 201,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('Error inserting dream:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e instanceof Error ? e.message : String(e) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

if (request.method === 'GET' && pathParts.length === 2 && pathParts[0] === 'dreams') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  if (!(await isTrialActive(userEmail, env))) {
    return new Response(JSON.stringify({ error: 'Trial expired' }), {
      status: 403,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const id = pathParts[1];
  if (!id) {
    return new Response(JSON.stringify({ error: 'Missing dream id' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  try {
    const d1 = env.DB;
    const row = await d1
      .prepare('SELECT * FROM dreams WHERE id = ? AND user = ?')
      .bind(id, userEmail)
      .first();

    if (!row) {
      return new Response(JSON.stringify({ error: 'Dream not found' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      });
    }

    // –ü–∞—Ä—Å–∏–º blocks
    if (row.blocks) {
      try {
        row.blocks = JSON.parse(row.blocks);
      } catch {
        row.blocks = [];
      }
    } else {
      row.blocks = [];
    }

    // –ó–∞–≥—Ä—É–∂–∞–µ–º similarArtworks –∏–∑ dream_similar_artworks + artworks
    const similarRes = await d1.prepare(`
      SELECT
        a.id AS artworkId,
        a.title,
        a.author,
        a.desc,
        a.value,
        a.type,
        dsa.position AS rank
      FROM dream_similar_artworks dsa
      JOIN artworks a ON dsa.artwork_id = a.id
      WHERE dsa.dream_id = ?
      ORDER BY dsa.position ASC
    `).bind(id).all();

    row.similarArtworks = (similarRes.results || []).map((art) => ({
      artworkId: art.artworkId,
      title: art.title,
      author: art.author,
      desc: art.desc,
      value: art.value,
      type: art.type,
      rank: art.rank,
      imageUrl: art.value, // –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
    }));

    return new Response(JSON.stringify(normalizeDream(row)), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  } catch (e) {
    console.error('Error fetching dream:', e);
    return new Response(
      JSON.stringify({ error: 'internal_error', message: e.message }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      }
    );
  }
}

    if (url.pathname.startsWith('/dreams/') && request.method === 'DELETE') {
      const userEmail = await getUserEmail(request);
      if (!userEmail) {
        return new Response(JSON.stringify({ error: 'unauthorized' }), {
          status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      if (!(await isTrialActive(userEmail, env))) {
        return new Response(JSON.stringify({ error: 'Trial expired' }), {
          status: 403, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      const id = url.pathname.split('/')[2];
      if (!id) {
        return new Response(JSON.stringify({ error: 'Missing dream id' }), {
          status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      try {
        const d1 = env.DB;
        const result = await d1.prepare('DELETE FROM dreams WHERE id = ? AND user = ?').bind(id, userEmail).run();
        if (result.changes === 0) {
          return new Response(JSON.stringify({ error: 'Dream not found' }), {
            status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
        return new Response(JSON.stringify({ success: true }), {
          status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (e) {
        console.error('Error deleting dream:', e);
        return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
          status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // PUT /dreams/:dreamId/messages/:messageId/artwork_like
// pathParts example: ['dreams', '<dreamId>', 'messages', '<messageId>', 'artwork_like'] -> length === 5
if (request.method === 'PUT' && pathParts.length === 5 && pathParts[0] === 'dreams' && pathParts[2] === 'messages' && pathParts[4] === 'artwork_like') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), { status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }
  if (!(await isTrialActive(userEmail, env))) {
    return new Response(JSON.stringify({ error: 'Trial expired' }), { status: 403, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }

  const dreamId = pathParts[1];
  const messageId = pathParts[3];

  let body;
  try { body = await request.json(); } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), { status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }

  const { liked } = body || {};
  if (typeof liked !== 'boolean') {
    return new Response(JSON.stringify({ error: 'liked must be boolean' }), { status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }

  try {
    const message = await toggleMessageArtworkInsight(env, {
      dreamId,
      messageId,
      liked,
      userEmail
    });
    if (!message) {
      return new Response(JSON.stringify({ error: '–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' }), { status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
    }

    return new Response(JSON.stringify({
      id: message.id,
      role: message.role,
      content: message.content,
      meta: message.meta ? JSON.parse(message.meta) : {},
      createdAt: message.created_at
    }), { status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  } catch (err) {
    console.error('toggle artwork like error', err);
    return new Response(JSON.stringify({ error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–Ω—Å–∞–π—Ç' }), { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }
}

// PUT /dreams/:dreamId/messages/:messageId/like
if (request.method === 'PUT' && pathParts.length === 5 && pathParts[0] === 'dreams' && pathParts[2] === 'messages' && pathParts[4] === 'like') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  if (!(await isTrialActive(userEmail, env))) {
    return new Response(JSON.stringify({ error: 'Trial expired' }), {
      status: 403,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const dreamId = pathParts[1];
  const messageId = pathParts[3];

  let body;
  try { body = await request.json(); } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const { liked } = body || {};
  if (typeof liked !== 'boolean') {
    return new Response(JSON.stringify({ error: 'liked must be boolean' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const message = await toggleMessageInsight(env, {
      dreamId,
      messageId,
      liked,
      userEmail
    });
    if (!message) {
      return new Response(JSON.stringify({ error: '–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    return new Response(JSON.stringify({
      id: message.id,
      role: message.role,
      content: message.content,
      meta: message.meta ? JSON.parse(message.meta) : {},
      createdAt: message.created_at
    }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (err) {
    console.error('toggle like error', err);
    return new Response(JSON.stringify({ error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–Ω—Å–∞–π—Ç' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// PUT /daily_convos/:dailyConvoId/messages/:messageId/artwork_like
if (request.method === 'PUT' && pathParts.length === 5 && pathParts[0] === 'daily_convos' && pathParts[2] === 'messages' && pathParts[4] === 'artwork_like') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) return new Response(JSON.stringify({ error: 'unauthorized' }), { status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  const dailyConvoId = pathParts[1];
  const messageId = pathParts[3];
  let body;
  try { body = await request.json(); } catch { return new Response(JSON.stringify({ error: 'Invalid JSON' }), { status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders } }); }
  const { liked } = body || {};
  if (typeof liked !== 'boolean') return new Response(JSON.stringify({ error: 'liked must be boolean' }), { status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  try {
    const message = await toggleDailyMessageArtworkInsight(env, { dailyConvoId, messageId, liked, userEmail });
    if (!message) return new Response(JSON.stringify({ error: '–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' }), { status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
    return new Response(JSON.stringify({ id: message.id, role: message.role, content: message.content, meta: message.meta ? JSON.parse(message.meta) : {}, createdAt: message.created_at }), { status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  } catch (err) {
    console.error('toggle daily artwork like error', err);
    return new Response(JSON.stringify({ error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–Ω—Å–∞–π—Ç' }), { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }
}

// PUT /daily_convos/:dailyConvoId/messages/:messageId/like
if (request.method === 'PUT' && pathParts.length === 5 && pathParts[0] === 'daily_convos' && pathParts[2] === 'messages' && pathParts[4] === 'like') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) return new Response(JSON.stringify({ error: 'unauthorized' }), { status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  const dailyConvoId = pathParts[1];
  const messageId = pathParts[3];
  let body;
  try { body = await request.json(); } catch { return new Response(JSON.stringify({ error: 'Invalid JSON' }), { status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders } }); }
  const { liked } = body || {};
  if (typeof liked !== 'boolean') return new Response(JSON.stringify({ error: 'liked must be boolean' }), { status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  try {
    const message = await toggleDailyMessageInsight(env, { dailyConvoId, messageId, liked, userEmail });
    if (!message) return new Response(JSON.stringify({ error: '–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' }), { status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
    return new Response(JSON.stringify({ id: message.id, role: message.role, content: message.content, meta: message.meta ? JSON.parse(message.meta) : {}, createdAt: message.created_at }), { status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  } catch (err) {
    console.error('toggle daily like error', err);
    return new Response(JSON.stringify({ error: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–Ω—Å–∞–π—Ç' }), { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }
}

// GET /dreams/:dreamId/insights
if (
  request.method === 'GET' &&
  pathParts.length === 3 &&
  pathParts[0] === 'dreams' &&
  pathParts[2] === 'insights'
) {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }
  if (!(await isTrialActive(userEmail, env))) {
    return new Response(JSON.stringify({ error: 'Trial expired' }), {
      status: 403,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const dreamId = pathParts[1];
  const url = new URL(request.url);
  const metaKey = url.searchParams.get('metaKey');

  // Whitelist —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω—ã—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤
  const allowedFilters = {
    insightArtworksLiked: `CAST(json_extract(meta, '$.insightArtworksLiked') AS REAL) = 1`,
    insightLiked: `CAST(json_extract(meta, '$.insightLiked') AS REAL) = 1`,
  };

  // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî –∫–∞–∫ —Ä–∞–Ω—å—à–µ (–æ–±–∞ —Ñ–ª–∞–≥–∞)
  const filterClause = allowedFilters[metaKey]
    ? `AND (${allowedFilters[metaKey]})`
    : `
      AND (
        CAST(json_extract(meta, '$.insightLiked') AS REAL) = 1
        OR CAST(json_extract(meta, '$.insightArtworksLiked') AS REAL) = 1
      )
    `;

  try {
    const { results } = await env.DB.prepare(`
      SELECT id, content, meta, created_at
      FROM messages
      WHERE dream_id = ?
        AND user = ?
        ${filterClause}
      ORDER BY created_at DESC
    `).bind(dreamId, userEmail).all();

    const insights = (results ?? []).map((row) => {
      const meta = row.meta ? JSON.parse(row.meta) : {};
      const createdAt =
        typeof row.created_at === 'number'
          ? new Date(row.created_at).toISOString()
          : row.created_at;

      // –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏: –µ—Å–ª–∏ metaKey=insightArtworksLiked, —Ç–æ insightLiked = insightArtworksLiked
      const artworksFlag = Boolean(meta.insightArtworksLiked ?? meta.insight_artworks_liked ?? 0);
      const likedFlag = Boolean(
        meta.insightLiked ?? meta.insight_liked ?? meta.liked ?? meta.isFavorite ?? meta.isInsight ?? meta.favorite
      );

      return {
        messageId: row.id,
        text: row.content,
        createdAt,
        blockId: meta.blockId ?? meta.block_id ?? null,
        insightLiked: metaKey === 'insightArtworksLiked' ? artworksFlag : likedFlag,
        insightArtworksLiked: artworksFlag,
        meta,
      };
    });

    return new Response(JSON.stringify({ insights }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  } catch (err) {
    console.error('fetch insights error', err);
    return new Response(JSON.stringify({ error: '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–Ω—Å–∞–π—Ç—ã' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }
}

// GET /daily_convos/:id/insights
if (request.method === 'GET' && pathParts.length === 3 && pathParts[0] === 'daily_convos' && pathParts[2] === 'insights') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) return new Response(JSON.stringify({ error: 'unauthorized' }), { status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  const dailyId = pathParts[1];
  const urlObj = new URL(request.url);
  const metaKey = urlObj.searchParams.get('metaKey');

  const allowedFilters = {
    insightArtworksLiked: `CAST(json_extract(meta, '$.insightArtworksLiked') AS REAL) = 1`,
    insightLiked: `CAST(json_extract(meta, '$.insightLiked') AS REAL) = 1`,
  };

  const filterClause = allowedFilters[metaKey] ? `AND (${allowedFilters[metaKey]})` : `
    AND (
      CAST(json_extract(meta, '$.insightLiked') AS REAL) = 1
      OR CAST(json_extract(meta, '$.insightArtworksLiked') AS REAL) = 1
    )
  `;

  try {
    const { results } = await env.DB.prepare(`
      SELECT id, content, meta, created_at
      FROM messages
      WHERE dream_id = ? AND user = ? ${filterClause}
      ORDER BY created_at DESC
    `).bind(dailyId, userEmail).all();

    const insights = (results ?? []).map(row => {
      const meta = row.meta ? JSON.parse(row.meta) : {};
      const createdAt = typeof row.created_at === 'number' ? new Date(row.created_at).toISOString() : row.created_at;
      const artworksFlag = Boolean(meta.insightArtworksLiked ?? meta.insight_artworks_liked ?? 0);
      const likedFlag = Boolean(meta.insightLiked ?? meta.insight_liked ?? meta.liked ?? meta.isFavorite ?? meta.isInsight ?? meta.favorite);
      return {
        messageId: row.id,
        text: row.content,
        createdAt,
        blockId: meta.blockId ?? meta.block_id ?? null,
        insightLiked: metaKey === 'insightArtworksLiked' ? artworksFlag : likedFlag,
        insightArtworksLiked: artworksFlag,
        meta
      };
    });

    return new Response(JSON.stringify({ insights }), { status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  } catch (err) {
    console.error('GET /daily_convos/:id/insights error', err);
    return new Response(JSON.stringify({ error: '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–Ω—Å–∞–π—Ç—ã' }), { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }
}

// worker.js ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –≤ –∫–æ–Ω—Ü–µ fetch handler
if (url.pathname.endsWith('/mood') && request.method === 'PUT') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const pathParts = url.pathname.split('/').filter(Boolean);
  if (pathParts.length < 3 || pathParts[pathParts.length - 2] !== 'dreams') {
    return new Response(JSON.stringify({ error: 'Invalid path' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const dreamId = pathParts[pathParts.length - 3];
  if (!dreamId) {
    return new Response(JSON.stringify({ error: 'Missing dreamId' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  let body;
  try { body = await request.json(); } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const { context } = body;
  if (!context) {
    return new Response(JSON.stringify({ error: 'context required' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    await env.DB.prepare(
      `UPDATE dreams SET context = ? WHERE id = ? AND user = ?`
    ).bind(context, dreamId, userEmail).run();

    return new Response(JSON.stringify({ success: true }), {
      status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('[MOOD FOR DREAM] PUT error:', e);
    return new Response(JSON.stringify({ error: 'database_error' }), {
      status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

    if (url.pathname.startsWith('/dreams/') && request.method === 'PUT') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  if (!(await isTrialActive(userEmail, env))) {
    return new Response(JSON.stringify({ error: 'Trial expired' }), {
      status: 403, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  let body;
  try {
    body = await request.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const validation = validateDreamData(body);
  if (!validation.valid) {
    return new Response(JSON.stringify({ error: 'Invalid dream data', message: validation.error }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const id = url.pathname.split('/')[2];
  if (!id) {
    return new Response(JSON.stringify({ error: 'Missing dream id' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const d1 = env.DB;
    const existing = await d1.prepare('SELECT * FROM dreams WHERE id = ? AND user = ?').bind(id, userEmail).first();
    if (!existing) {
      return new Response(JSON.stringify({ error: 'Dream not found' }), {
        status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const {
  dreamText = existing.dreamText,
  title = existing.title,
  category = existing.category,
  dreamSummary = existing.dreamSummary,
  globalFinalInterpretation = existing.globalFinalInterpretation,
  blocks = existing.blocks ? JSON.parse(existing.blocks) : [],
  // similarArtworks –±–æ–ª—å—à–µ –Ω–µ –±–µ—Ä—ë–º –∏–∑ body
  context = existing.context
} = body;

const similarArtworks = existing.similarArtworks || '[]';

    const textChanged = (existing.dreamText !== dreamText);

    await env.DB.prepare(
      `UPDATE dreams SET 
        title = ?, 
        dreamText = ?, 
        category = ?, 
        dreamSummary = ?, 
        globalFinalInterpretation = ?, 
        blocks = ?, 
        similarArtworks = ?, 
        context = ?,
        autoSummary = ${textChanged ? "NULL" : "autoSummary"}
      WHERE id = ? AND user = ?`
    ).bind(
      title,
      dreamText,
      category,
      dreamSummary,
      globalFinalInterpretation,
      JSON.stringify(blocks),
      similarArtworks, // ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–∑ existing
      context,
      id,
      userEmail
    ).run();

    const dream = {
      id,
      user: userEmail,
      title,
      dreamText,
      date: existing.date,
      category,
      dreamSummary,
      globalFinalInterpretation,
      blocks,
      similarArtworks,
      context,
      autoSummary: textChanged ? null : (existing.autoSummary ?? null)
    };

    return new Response(JSON.stringify(dream), {
      status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (e) {
    console.error('Error updating dream:', e);
    return new Response(
      JSON.stringify({ error: 'internal_error', message: e instanceof Error ? e.message : String(e) }),
      { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders } }
    );
  }
}

// --- DAILY CONVOS CRUD ---

// GET /daily_convos (list)
if (url.pathname === '/daily_convos' && request.method === 'GET') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) return new Response(JSON.stringify({ error: 'unauthorized' }), { status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  try {
    const res = await env.DB.prepare('SELECT * FROM daily_convos WHERE user = ? ORDER BY date DESC').bind(userEmail).all();
    const items = (res.results || []).map(r => {
      if (r.blocks) {
        try { r.blocks = JSON.parse(r.blocks); } catch { r.blocks = []; }
      } else r.blocks = [];
      return r;
    });
    return new Response(JSON.stringify(items), { status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  } catch (e) {
    console.error('GET /daily_convos error', e);
    return new Response(JSON.stringify({ error: 'internal_error' }), { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }
}

// POST /daily_convos (create)
if (url.pathname === '/daily_convos' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) return new Response(JSON.stringify({ error: 'unauthorized' }), { status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  let body;
  try { body = await request.json(); } catch { return new Response(JSON.stringify({ error: 'Invalid JSON' }), { status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders } }); }
  const { notes, title } = body || {};
  if (!notes || typeof notes !== 'string') return new Response(JSON.stringify({ error: 'notes required' }), { status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  const id = crypto.randomUUID();
  const date = Date.now();
  try {
    await env.DB.prepare(`
      INSERT INTO daily_convos (id, user, title, notes, date, blocks, globalFinalInterpretation, autoSummary, context)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(id, userEmail, title ?? null, notes.trim(), date, JSON.stringify([]), null, null, null).run();

    const created = { id, user: userEmail, title: title ?? null, notes: notes.trim(), date, blocks: [], globalFinalInterpretation: null, autoSummary: null, context: null };
    return new Response(JSON.stringify(created), { status: 201, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  } catch (e) {
    console.error('POST /daily_convos error', e);
    return new Response(JSON.stringify({ error: 'internal_error' }), { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }
}

// GET /daily_convos/:id
if (request.method === 'GET' && pathParts.length === 2 && pathParts[0] === 'daily_convos') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) return new Response(JSON.stringify({ error: 'unauthorized' }), { status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  const id = pathParts[1];
  try {
    const row = await env.DB.prepare('SELECT * FROM daily_convos WHERE id = ? AND user = ?').bind(id, userEmail).first();
    if (!row) return new Response(JSON.stringify({ error: 'Not found' }), { status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
    if (row.blocks) {
      try { row.blocks = JSON.parse(row.blocks); } catch { row.blocks = []; }
    } else row.blocks = [];
    return new Response(JSON.stringify(row), { status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  } catch (e) {
    console.error('GET /daily_convos/:id error', e);
    return new Response(JSON.stringify({ error: 'internal_error' }), { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }
}

// PUT /daily_convos/:id
if (request.method === 'PUT' && pathParts.length === 2 && pathParts[0] === 'daily_convos') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) return new Response(JSON.stringify({ error: 'unauthorized' }), { status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  const id = pathParts[1];
  let body;
  try { body = await request.json(); } catch { return new Response(JSON.stringify({ error: 'Invalid JSON' }), { status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders } }); }
  const { notes, title, blocks, globalFinalInterpretation, autoSummary, context } = body || {};
  try {
    const existing = await env.DB.prepare('SELECT * FROM daily_convos WHERE id = ? AND user = ?').bind(id, userEmail).first();
    if (!existing) return new Response(JSON.stringify({ error: 'Not found' }), { status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders }});

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, –µ—Å–ª–∏ –Ω–æ–≤—ã–µ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω—ã
    const newNotes = typeof notes !== 'undefined' ? notes : existing.notes;
    const newTitle = typeof title !== 'undefined' ? title : existing.title;
    const newBlocks = typeof blocks !== 'undefined' ? JSON.stringify(blocks) : existing.blocks;
    const newGlobalFinalInterpretation = typeof globalFinalInterpretation !== 'undefined' ? globalFinalInterpretation : existing.globalFinalInterpretation;
    const newAutoSummary = typeof autoSummary !== 'undefined' ? autoSummary : existing.autoSummary;
    const newContext = typeof context !== 'undefined' ? context : existing.context;

    await env.DB.prepare(`
      UPDATE daily_convos SET title = ?, notes = ?, blocks = ?, globalFinalInterpretation = ?, autoSummary = ?, context = ?
      WHERE id = ? AND user = ?
    `).bind(newTitle, newNotes, newBlocks, newGlobalFinalInterpretation, newAutoSummary, newContext, id, userEmail).run();

    const row = await env.DB.prepare('SELECT * FROM daily_convos WHERE id = ? AND user = ?').bind(id, userEmail).first();
    if (row.blocks) {
      try { row.blocks = JSON.parse(row.blocks); } catch { row.blocks = []; }
    } else row.blocks = [];
    return new Response(JSON.stringify(row), { status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  } catch (e) {
    console.error('PUT /daily_convos/:id error', e);
    return new Response(JSON.stringify({ error: 'internal_error' }), { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }
}

// DELETE /daily_convos/:id
if (request.method === 'DELETE' && pathParts.length === 2 && pathParts[0] === 'daily_convos') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) return new Response(JSON.stringify({ error: 'unauthorized' }), { status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  const id = pathParts[1];
  try {
    const res = await env.DB.prepare('DELETE FROM daily_convos WHERE id = ? AND user = ?').bind(id, userEmail).run();
    if (res.changes === 0) return new Response(JSON.stringify({ error: 'Not found' }), { status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
    return new Response(JSON.stringify({ success: true }), { status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  } catch (e) {
    console.error('DELETE /daily_convos/:id error', e);
    return new Response(JSON.stringify({ error: 'internal_error' }), { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }});
  }
}

// === –î–û–ë–ê–í–ò–¢–¨ –í worker.js ===
// –ù–∞–π—Ç–∏ –º–µ—Å—Ç–æ, –≥–¥–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –¥—Ä—É–≥–∏–µ –º–∞—Ä—à—Ä—É—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, if (url.pathname === '/dreams'))

// üëá –í–°–¢–ê–í–ò–¢–¨ –°–Æ–î–ê:

if (url.pathname === '/api/rolling_summary' && method === 'GET') {
  const user = await getUserFromRequest(request, env);
  if (!user) return unauthorizedResponse();

  const { searchParams } = new URL(request.url);
  const dreamId = searchParams.get('dreamId');
  const blockId = searchParams.get('blockId');
  const artworkId = searchParams.get('artworkId') || null;

  if (!dreamId || !blockId) {
    return jsonResponse({ error: 'dreamId and blockId are required' }, 400);
  }

  try {
    const summaryData = await getRollingSummary(env, user, dreamId, blockId, artworkId);
    if (!summaryData) {
      return jsonResponse({ error: 'Summary not found' }, 404);
    }
    return jsonResponse(summaryData);
  } catch (e) {
    console.error('[ROLLING SUMMARY API ERROR]', e);
    return jsonResponse({ error: 'Internal server error' }, 500);
  }
}

// --- CHAT: get history ---
if (url.pathname === '/chat' && request.method === 'GET') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  const dreamId = url.searchParams.get('dreamId');
  const blockId = url.searchParams.get('blockId');
  if (!dreamId || !blockId) {
    return new Response(JSON.stringify({ error: 'Missing dreamId or blockId' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  try {
    const d1 = env.DB;
    const res = await d1.prepare(
      `SELECT id, role, content, created_at, meta
       FROM messages
       WHERE user = ? AND dream_id = ? AND block_id = ?
       ORDER BY created_at ASC`
    ).bind(userEmail, dreamId, blockId).all();

    const messages = (res.results || []).map(r => ({
      id: r.id,
      role: r.role,
      content: r.content,
      created_at: r.created_at,
      meta: r.meta ? JSON.parse(r.meta) : undefined
    }));

    return new Response(JSON.stringify({ messages }), {
      status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('GET /chat error:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
      status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- CHAT: append message ---
if (url.pathname === '/chat' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  let body;
  try { body = await request.json(); } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  const { id, dreamId, blockId, role, content, meta } = body || {};
  if (!dreamId || !blockId || !role || !content || !['user','assistant'].includes(role)) {
    return new Response(JSON.stringify({ error: 'Invalid payload' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  const msgId = id || crypto.randomUUID();
  const createdAt = Date.now();
  try {
    const d1 = env.DB;
    await d1.prepare(
      `INSERT INTO messages (id, user, dream_id, block_id, role, content, created_at, meta)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`
    ).bind(
      msgId, userEmail, dreamId, blockId, role, String(content).slice(0, 12000),
      createdAt, meta ? JSON.stringify(meta) : null
    ).run();

    return new Response(JSON.stringify({
      id: msgId, role, content, created_at: createdAt, meta: meta ?? null
    }), {
      status: 201, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('POST /chat error:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
      status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}



// --- CHAT: clear history for block ---
if (url.pathname === '/chat' && request.method === 'DELETE') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  const dreamId = url.searchParams.get('dreamId');
  const blockId = url.searchParams.get('blockId');
  if (!dreamId || !blockId) {
    return new Response(JSON.stringify({ error: 'Missing dreamId or blockId' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  try {
    const d1 = env.DB;
    await d1.prepare(
      `DELETE FROM messages WHERE user = ? AND dream_id = ? AND block_id = ?`
    ).bind(userEmail, dreamId, blockId).run();

    await d1.prepare(
      `DELETE FROM dialog_summaries WHERE user = ? AND dream_id = ? AND block_id = ?`
    ).bind(userEmail, dreamId, blockId).run();

    return new Response(JSON.stringify({ success: true }), {
      status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('DELETE /chat error:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
      status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- DAILY CHAT: GET /daily_chat?dailyConvoId=... ---
if (url.pathname === '/daily_chat' && request.method === 'GET') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const dailyConvoId = url.searchParams.get('dailyConvoId');
  if (!dailyConvoId) {
    return new Response(JSON.stringify({ error: 'Missing dailyConvoId' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  try {
    const res = await env.DB.prepare(
      `SELECT id, role, content, created_at, meta
       FROM messages
       WHERE user = ? AND dream_id = ?
       ORDER BY created_at ASC`
    ).bind(userEmail, dailyConvoId).all();

    const messages = (res.results || []).map((r) => ({
  id: r.id,
  role: r.role,
  content: r.content,
  created_at: r.created_at,
  meta: r.meta ? JSON.parse(r.meta) : undefined,
  artworkId: r.artwork_id || null, // ‚Üê –¥–æ–±–∞–≤–ª—è–µ–º artworkId
}));

    return new Response(JSON.stringify({ messages }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  } catch (e) {
    console.error('GET /daily_chat error', e && (e.stack || e.message || e));
    return new Response(
      JSON.stringify({
        error: 'internal_error',
        details: e?.message || String(e)
      }),
      { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders } }
    );
  }
}

// --- POST /daily_chat ---
if (url.pathname === '/daily_chat' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  let body;
  try {
    body = await request.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const { id, dailyConvoId, role, content, meta, blockId } = body || {};
  if (!dailyConvoId || !role || !content || !['user', 'assistant'].includes(role)) {
    return new Response(JSON.stringify({ error: 'Invalid payload' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const msgId = id || crypto.randomUUID();
  const createdAt = Date.now();

  // block_id in schema is NOT NULL ‚Äî use empty string when not provided
  const safeBlockId = (typeof blockId === 'string' && blockId.length > 0) ? blockId : '';

  try {
    await env.DB.prepare(
      `INSERT INTO messages (id, user, dream_id, block_id, role, content, created_at, meta)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`
    )
      .bind(
        msgId,
        userEmail,
        dailyConvoId,
        safeBlockId,
        role,
        String(content).slice(0, 12000),
        createdAt,
        meta ? JSON.stringify(meta) : null
      )
      .run();

    // üÜï –î–û–ë–ê–í–¨ –°–Æ–î–ê: –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ rolling summary
if (role === 'assistant') {
  try {
    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –∑–∞–ø–∏—Å–∏ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
    const dailyRow = await env.DB.prepare(
      'SELECT notes FROM daily_convos WHERE id = ? AND user = ?'
    ).bind(dailyConvoId, userEmail).first();
    
    const notesText = dailyRow?.notes || '';
    
    await updateRollingSummary(
      env,
      userEmail,
      dailyConvoId,        // ‚Üê dream_id
      safeBlockId,         // ‚Üê block_id
      notesText,           // ‚Üê —Ç–µ–∫—Å—Ç –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
      env.DEEPSEEK_API_KEY,
      null                 // ‚Üê artwork_id (null –¥–ª—è daily_chat)
    );
  } catch (e) {
    console.warn('[POST /daily_chat] Failed to update summary:', e);
  }
}

    return new Response(
      JSON.stringify({
        id: msgId,
        role,
        content,
        created_at: createdAt,
        meta: meta ?? null,
      }),
      {
        status: 201,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      }
    );
  } catch (e) {
    console.error('POST /daily_chat DB error', e && (e.stack || e.message || e));
    return new Response(
      JSON.stringify({
        error: 'internal_error',
        details: e?.message || String(e)
      }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      }
    );
  }
}

// --- DELETE /daily_chat?dailyConvoId=... ---
if (url.pathname === '/daily_chat' && request.method === 'DELETE') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const dailyConvoId = url.searchParams.get('dailyConvoId');
  if (!dailyConvoId) {
    return new Response(JSON.stringify({ error: 'Missing dailyConvoId' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  try {
    await env.DB.prepare(
      `DELETE FROM messages WHERE user = ? AND dream_id = ?`
    )
      .bind(userEmail, dailyConvoId)
      .run();

    await env.DB.prepare(
      `DELETE FROM dialog_summaries WHERE user = ? AND dream_id = ? AND block_id IS NULL`
    )
      .bind(userEmail, dailyConvoId)
      .run()
      .catch(() => {});

    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  } catch (e) {
    console.error('DELETE /daily_chat error', e && (e.stack || e.message || e));
    return new Response(
      JSON.stringify({
        error: 'internal_error',
        details: e?.message || String(e)
      }),
      { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders } }
    );
  }
}

    // --- Generate Auto Summary endpoint (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π) ---
if (url.pathname === '/generate_auto_summary' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  let body;
  try {
    body = await request.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const { dreamId, dreamText } = body;
  if (!dreamId || !dreamText) {
    return new Response(JSON.stringify({ error: 'Missing dreamId or dreamText' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const d1 = env.DB;
    const existing = await d1
      .prepare('SELECT dreamText, autoSummary FROM dreams WHERE id = ? AND user = ?')
      .bind(dreamId, userEmail)
      .first();

    if (!existing) {
      return new Response(JSON.stringify({ error: 'Dream not found' }), {
        status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    if (existing.autoSummary && existing.dreamText === dreamText) {
      return new Response(JSON.stringify({ success: true, autoSummary: existing.autoSummary }), {
        status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const prompt = `–°–æ–∑–¥–∞–π –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ —ç—Ç–æ–≥–æ —Å–Ω–æ–≤–∏–¥–µ–Ω–∏—è –≤ 2-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è—Ö. –í—ã–¥–µ–ª–∏ –∫–ª—é—á–µ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã: –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π, –ª–æ–∫–∞—Ü–∏–∏, –¥–µ–π—Å—Ç–≤–∏—è –∏ —ç–º–æ—Ü–∏–∏. –ü–∏—à–∏ –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ —Å—É—â–µ—Å—Ç–≤—É, –±–µ–∑ –≤–æ–ø—Ä–æ—Å–æ–≤ –∏ –æ–±—Ä–∞—â–µ–Ω–∏–π.\n\n–¢–µ–∫—Å—Ç —Å–Ω–∞:\n${dreamText.slice(0, 4000)}`;

    const deepseekRequestBody = {
      model: 'deepseek-chat',
      messages: [
        { role: 'system', content: '–¢—ã —Å–æ–∑–¥–∞—ë—à—å –∫—Ä–∞—Ç–∫–∏–µ —Ä–µ–∑—é–º–µ —Å–Ω–æ–≤–∏–¥–µ–Ω–∏–π. –ü–∏—à–∏ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ, –∫—Ä–∞—Ç–∫–æ, —Ç–æ–ª—å–∫–æ —Ñ–∞–∫—Ç—ã –∏ –∫–ª—é—á–µ–≤—ã–µ –æ–±—Ä–∞–∑—ã.' },
        { role: 'user', content: prompt }
      ],
      max_tokens: 200,
      temperature: 0.5,
      stream: false
    };

    const deepseekResponse = await fetch('https://api.deepseek.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${env.DEEPSEEK_API_KEY}`
      },
      body: JSON.stringify(deepseekRequestBody)
    });

    let responseBody = await deepseekResponse.json();
    let autoSummary = responseBody?.choices?.[0]?.message?.content || '';
    autoSummary = autoSummary.replace(/```[\s\S]*?```/g, '').replace(/^["'`]+|["'`]+$/g, '').trim();

    await d1.prepare('UPDATE dreams SET autoSummary = ? WHERE id = ? AND user = ?')
      .bind(autoSummary, dreamId, userEmail)
      .run();

    return new Response(JSON.stringify({ success: true, autoSummary }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('Error generating auto summary:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- Analyze endpoint (—Å rolling summary) ---
if (url.pathname === '/analyze' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({
      error: 'unauthorized',
      message: 'Invalid or missing authorization token'
    }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  if (!(await isTrialActive(userEmail, env))) {
    return new Response(JSON.stringify({ error: 'Trial expired' }), {
      status: 403,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const contentType = request.headers.get('content-type') || '';
    if (!contentType.includes('application/json')) {
      return new Response(JSON.stringify({
        error: 'Invalid content type',
        message: 'Content-Type must be application/json'
      }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const requestData = await request.json();
    const { blockText, lastTurns, extraSystemPrompt, dreamId, blockId, artworkId } = requestData;

    // 1. –ü–æ–ª—É—á–∞–µ–º rolling summary (‚úÖ –¢–ï–ü–ï–†–¨ –° artworkId)
    let rollingSummary = null;
    if (dreamId && blockId) {
      const summaryData = await getRollingSummary(
        env, 
        userEmail, 
        dreamId, 
        blockId, 
        artworkId ?? null  // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û
      );
      rollingSummary = summaryData?.summary || null;

      console.log('[analyze] Summary state:', { 
        hasSummary: !!summaryData, 
        dreamId, 
        blockId,
        artworkId: artworkId ?? null
      });

      // 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å summary
      const d1 = env.DB;
      let countQuery = `SELECT COUNT(*) as count FROM messages WHERE user = ? AND dream_id = ? AND block_id = ?`;
      let countParams = [userEmail, dreamId, blockId];

      if (artworkId) {
        countQuery += ` AND artwork_id = ?`;
        countParams.push(artworkId);
      }

      const allMessagesRes = await d1.prepare(countQuery).bind(...countParams).first();
      const currentMessageCount = allMessagesRes?.count || 0;

      console.log('[analyze] Message count:', currentMessageCount);

      // üÜï –ï—Å–ª–∏ summary –Ω–µ—Ç, –Ω–æ –µ—Å—Ç—å —Ö–æ—Ç—è –±—ã 2 —Å–æ–æ–±—â–µ–Ω–∏—è ‚Äî —Å–æ–∑–¥–∞—ë–º
      if (!summaryData && currentMessageCount >= 2) {
        console.log('[analyze] Creating initial summary');
        try {
          rollingSummary = await updateRollingSummary(
            env, userEmail, dreamId, blockId, blockText, env.DEEPSEEK_API_KEY, artworkId ?? null
          );
        } catch (e) {
          console.error('[analyze] Failed to create initial summary:', e);
        }
      } 
      // –ï—Å–ª–∏ summary –µ—Å—Ç—å, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Ä–æ–≥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
      else if (summaryData) {
        const newMessageCount = currentMessageCount - summaryData.lastMessageCount;

        console.log('[analyze] New messages since last summary:', newMessageCount);

        if (newMessageCount >= SUMMARY_UPDATE_THRESHOLD) {
          console.log('[analyze] Updating summary');
          try {
            rollingSummary = await updateRollingSummary(
              env, userEmail, dreamId, blockId, blockText, env.DEEPSEEK_API_KEY, artworkId ?? null
            );
          } catch (e) {
            console.error('[analyze] Failed to update summary:', e);
          }
        }
      }
    }

    let messages = [];
    const isArtworkDialog = blockId?.startsWith('artwork__');
    const systemPrompt = isArtworkDialog ? ARTDIALOG_SYSTEM_PROMPT : DIALOG_SYSTEM_PROMPT;

    messages.push({ role: 'system', content: systemPrompt });

    const d1 = env.DB;
    let dreamSummary = null;
    let autoSummary = null;

    if (dreamId) {
      const dreamRow = await d1.prepare(
        `SELECT dreamSummary, autoSummary FROM dreams WHERE id = ? AND user = ?`
      ).bind(dreamId, userEmail).first();

      if (dreamRow) {
        dreamSummary = dreamRow.dreamSummary || null;
        autoSummary = dreamRow.autoSummary || null;
      }
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –≤—ã–∂–∏–º–∫—É —Å–Ω–∞
    if (autoSummary) {
      messages.push({ role: 'system', content: `–í–´–ñ–ò–ú–ö–ê –°–ù–ê:\n${autoSummary}` });
    }

    // –î–æ–±–∞–≤–ª—è–µ–º —Å—É–±—ä–µ–∫—Ç–∏–≤–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if (dreamSummary) {
      messages.push({ role: 'system', content: `–°–£–ë–™–ï–ö–¢–ò–í–ù–´–ô –ö–û–ù–¢–ï–ö–°–¢ –û–¢ –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø:\n${dreamSummary}` });
    }

    // –î–æ–±–∞–≤–ª—è–µ–º rolling summary –¥–∏–∞–ª–æ–≥–∞
    if (rollingSummary) {
      messages.push({ role: 'system', content: `ROLLING SUMMARY –î–ò–ê–õ–û–ì–ê:\n${rollingSummary}` });
    }

    // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç —Ç–µ–∫—É—â–µ–≥–æ –±–ª–æ–∫–∞
    messages.push({ role: 'system', content: `–¢–ï–ö–£–©–ò–ô –ë–õ–û–ö:\n${(blockText || '').slice(0, 4000)}` });

    if (Array.isArray(lastTurns) && lastTurns.length) {
      messages.push(...lastTurns);
    }

    if (extraSystemPrompt) {
      messages.push({ role: 'system', content: extraSystemPrompt });
    }

    const deepseekRequestBody = {
      model: 'deepseek-chat',
      messages,
      max_tokens: 500,
      temperature: 0.7,
      stream: false
    };

    const deepseekResponse = await fetch('https://api.deepseek.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${env.DEEPSEEK_API_KEY}`
      },
      body: JSON.stringify(deepseekRequestBody)
    });

    let responseBody = await deepseekResponse.json();
    let content = responseBody?.choices?.[0]?.message?.content || '';
    content = content.replace(/```[\s\S]*?```/g, '').trim();
    if (!content) content = responseBody?.choices?.[0]?.message?.content || '';
    responseBody.choices[0].message.content = content;

    return new Response(JSON.stringify(responseBody), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (error) {
    console.error('Error in analyze endpoint:', error);
    return new Response(JSON.stringify({
      error: 'internal_error',
      message: error.message || 'Unknown error'
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- Analyze daily convo (clone of /analyze, for daily_convos) ---
if (url.pathname === '/analyze_daily_convo' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const contentType = request.headers.get('content-type') || '';
    if (!contentType.includes('application/json')) {
      return new Response(JSON.stringify({ error: 'Invalid content type', message: 'Content-Type must be application/json' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const body = await request.json();
    const { notesText, lastTurns = [], extraSystemPrompt, dailyConvoId, blockId, autoSummary } = body || {};

    if (!notesText || typeof notesText !== 'string') {
      return new Response(JSON.stringify({ error: 'No notesText' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    // choose system prompt (artwork vs daily vs main)
    let systemPrompt = DIALOG_SYSTEM_PROMPT;
    if (typeof blockId === 'string' && blockId.startsWith('artwork__')) {
      systemPrompt = ARTDIALOG_SYSTEM_PROMPT;
    } else if (blockId === 'daily_chat') {
      systemPrompt = DAILY_CHAT_SYSTEM_PROMPT;
    } else if (blockId === 'daily_artwork') {
      systemPrompt = DAILY_ARTWORK_PROMPT;
    }

    const messages = [];
    messages.push({ role: 'system', content: systemPrompt });

    // autoSummary if provided
    if (autoSummary) {
      messages.push({ role: 'system', content: `–í–´–ñ–ò–ú–ö–ê:\n${autoSummary}` });
    }

    // rolling summary if any (reuse getRollingSummary ‚Äî it expects (env, userEmail, dreamId, blockId))
    if (dailyConvoId) {
      try {
        const summaryData = await getRollingSummary(env, userEmail, dailyConvoId, blockId);
        if (summaryData?.summary) {
          messages.push({ role: 'system', content: `ROLLING SUMMARY –î–ò–ê–õ–û–ì–ê:\n${summaryData.summary}` });
        }
      } catch (e) {
        // non-fatal: log and continue
        console.warn('analyze_daily_convo: getRollingSummary failed', e);
      }
    }

    // main text
    messages.push({ role: 'system', content: `–¢–ï–ö–°–¢:\n${(notesText || '').slice(0, 4000)}` });

    if (Array.isArray(lastTurns) && lastTurns.length) {
      messages.push(...lastTurns);
    }

    if (extraSystemPrompt) {
      messages.push({ role: 'system', content: extraSystemPrompt });
    }

    const deepseekRequestBody = {
      model: 'deepseek-chat',
      messages,
      max_tokens: 500,
      temperature: 0.7,
      stream: false
    };

    const deepseekResponse = await fetch('https://api.deepseek.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${env.DEEPSEEK_API_KEY}`
      },
      body: JSON.stringify(deepseekRequestBody)
    });

    let responseBody = await deepseekResponse.json();
    let content = responseBody?.choices?.[0]?.message?.content || '';
    content = content.replace(/```[\s\S]*?```/g, '').trim();
    responseBody.choices[0].message.content = content;

    return new Response(JSON.stringify(responseBody), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (err) {
    console.error('Error in /analyze_daily_convo:', err);
    return new Response(JSON.stringify({ error: 'internal_error', message: err?.message || String(err) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- Generate Auto Summary for Daily Convo ---
if (url.pathname === '/generate_auto_summary_daily_convo' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  let body;
  try {
    body = await request.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  const { dailyConvoId, notes } = body;
  if (!dailyConvoId || !notes) {
    return new Response(JSON.stringify({ error: 'Missing dailyConvoId or notes' }), {
      status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const d1 = env.DB;
    const existing = await d1
      .prepare('SELECT notes, autoSummary FROM daily_convos WHERE id = ? AND user = ?')
      .bind(dailyConvoId, userEmail)
      .first();

    if (!existing) {
      return new Response(JSON.stringify({ error: 'Daily convo not found' }), {
        status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    if (existing.autoSummary && existing.notes === notes) {
      return new Response(JSON.stringify({ success: true, autoSummary: existing.autoSummary }), {
        status: 200, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const prompt = `–°–æ–∑–¥–∞–π –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ —ç—Ç–æ–π –∑–∞–ø–∏—Å–∏ –≤ 2-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è—Ö. –í—ã–¥–µ–ª–∏ –∫–ª—é—á–µ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã: —Å–æ–±—ã—Ç–∏—è, —ç–º–æ—Ü–∏–∏, –º—ã—Å–ª–∏. –ü–∏—à–∏ –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ —Å—É—â–µ—Å—Ç–≤—É.\n\n–¢–µ–∫—Å—Ç –∑–∞–ø–∏—Å–∏:\n${notes.slice(0, 4000)}`;

    const deepseekRequestBody = {
      model: 'deepseek-chat',
      messages: [
        { role: 'system', content: '–¢—ã —Å–æ–∑–¥–∞—ë—à—å –∫—Ä–∞—Ç–∫–∏–µ —Ä–µ–∑—é–º–µ –∑–∞–ø–∏—Å–µ–π. –ü–∏—à–∏ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ, –∫—Ä–∞—Ç–∫–æ, —Ç–æ–ª—å–∫–æ —Ñ–∞–∫—Ç—ã –∏ –∫–ª—é—á–µ–≤—ã–µ –æ–±—Ä–∞–∑—ã.' },
        { role: 'user', content: prompt }
      ],
      max_tokens: 200,
      temperature: 0.5,
      stream: false
    };

    const deepseekResponse = await fetch('https://api.deepseek.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${env.DEEPSEEK_API_KEY}`
      },
      body: JSON.stringify(deepseekRequestBody)
    });

    let responseBody = await deepseekResponse.json();
    let autoSummary = responseBody?.choices?.[0]?.message?.content || '';
    autoSummary = autoSummary.replace(/```[\s\S]*?```/g, '').replace(/^["'`]+|["'`]+$/g, '').trim();

    await d1.prepare('UPDATE daily_convos SET autoSummary = ? WHERE id = ? AND user = ?')
      .bind(autoSummary, dailyConvoId, userEmail)
      .run();

    return new Response(JSON.stringify({ success: true, autoSummary }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  } catch (e) {
    console.error('Error generating auto summary for daily convo:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}


    // --- Flatten similar artworks helper ---
    function flattenSimilarArtworks(similarArr) {
      if (!Array.isArray(similarArr) || similarArr.length === 0) return [];
      if (similarArr[0]?.title && similarArr[0]?.author) return similarArr;
      if (similarArr[0]?.motif && Array.isArray(similarArr[0]?.works)) {
        let flat = [];
        for (const motifObj of similarArr) {
          for (const work of motifObj.works) {
            flat.push({
              title: work.title || '',
              author: work.author || '',
              desc: work.desc || '',
              value: work.value || ''
            });
          }
        }
        return flat.slice(0, 5);
      }
      return similarArr;
    }

    // --- calculateImprovementScore ---
function calculateImprovementScore(data) {
  const {
    total_dreams = 0,
    interpreted_count = 0,
    summarized_count = 0,
    artworks_count = 0,
    max_interpretation_length = 0
  } = data || {};

  if (total_dreams === 0) return 0;

  const interpretedRatio = interpreted_count / total_dreams;
  const summarizedRatio = summarized_count / total_dreams;
  const artworksRatio = artworks_count / total_dreams;

  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–ª–∏–Ω—É –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ (–¥–æ 500 —Å–∏–º–≤–æ–ª–æ–≤ ‚Äî –º–∞–∫—Å. –≤–µ—Å)
  const lengthScore = Math.min(1, (max_interpretation_length || 0) / 500);

  // –í–∑–≤–µ—à–µ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
  const score =
    0.4 * interpretedRatio +
    0.25 * summarizedRatio +
    0.2 * artworksRatio +
    0.15 * lengthScore;

  return Math.round(score * 100);
}

    // --- Find similar artworks endpoint ---
    if (url.pathname === '/find_similar' && request.method === 'POST') {
      const userEmail = await getUserEmail(request);
      if (!userEmail) {
        return new Response(JSON.stringify({ error: 'unauthorized' }), {
          status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      if (!(await isTrialActive(userEmail, env))) {
        return new Response(JSON.stringify({ error: 'Trial expired' }), {
          status: 403, headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
      try {
        const body = await request.json();
        const { dreamText, globalFinalInterpretation, blockInterpretations } = body;
        if (!dreamText) {
          return new Response(JSON.stringify({ error: 'No dreamText' }), {
            status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }

        let contextParts = [];
        contextParts.push(`–°—é–∂–µ—Ç —Å–Ω–∞: """${dreamText}"""`);
        if (globalFinalInterpretation && globalFinalInterpretation.trim()) {
          contextParts.push(`–ò—Ç–æ–≥–æ–≤–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ —Å–Ω–∞: """${globalFinalInterpretation.trim()}"""`);
        }
        if (blockInterpretations && blockInterpretations.trim()) {
          contextParts.push(`–¢–æ–ª–∫–æ–≤–∞–Ω–∏—è –±–ª–æ–∫–æ–≤:\n${blockInterpretations.trim()}"""`);
        }

        const contextText = contextParts.join('\n\n');

        const prompt = `–¢—ã ‚Äî —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –∏—Å–∫—É—Å—Å—Ç–≤—É –∏ –ø—Å–∏—Ö–æ–∞–Ω–∞–ª–∏–∑—É. –ù–∞ –æ—Å–Ω–æ–≤–µ —Å–Ω–∞ –∏ –µ–≥–æ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏—è –ø–æ–¥–±–µ—Ä–∏ 5 –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–π –∏—Å–∫—É—Å—Å—Ç–≤–∞, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–∑–æ–Ω–∏—Ä—É—é—Ç —Å –æ–±—Ä–∞–∑–∞–º–∏ –∏ –º–æ—Ç–∏–≤–∞–º–∏ —Å–Ω–∞.

${contextText}

–î–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è —É–∫–∞–∂–∏:
- title: –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
- author: –∞–≤—Ç–æ—Ä
- desc: –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ (1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è), –ø–æ—á–µ–º—É —ç—Ç–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å–≤—è–∑–∞–Ω–æ —Å–æ —Å–Ω–æ–º
- value: —Å—Å—ã–ª–∫–∞ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (–µ—Å–ª–∏ –∏–∑–≤–µ—Å—Ç–Ω–∞) –∏–ª–∏ –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞
- type: —Ç–∏–ø –∏—Å–∫—É—Å—Å—Ç–≤–∞ ‚Äî **–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û** –≤—ã–±–µ—Ä–∏ –û–î–ò–ù –∏–∑ —ç—Ç–æ–≥–æ —Å–ø–∏—Å–∫–∞:
  * "painting" ‚Äî –∫–∞—Ä—Ç–∏–Ω–∞, –∂–∏–≤–æ–ø–∏—Å—å
  * "sculpture" ‚Äî —Å–∫—É–ª—å–ø—Ç—É—Ä–∞
  * "installation" ‚Äî –∏–Ω—Å—Ç–∞–ª–ª—è—Ü–∏—è
  * "book" ‚Äî –∫–Ω–∏–≥–∞, —Ä–æ–º–∞–Ω, –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞
  * "music" ‚Äî –º—É–∑—ã–∫–∞, —Å–∏–º—Ñ–æ–Ω–∏—è, –æ–ø–µ—Ä–∞
  * "movie" ‚Äî —Ñ–∏–ª—å–º, –∫–∏–Ω–æ
  * "theater" ‚Äî —Ç–µ–∞—Ç—Ä, –ø—å–µ—Å–∞
  * "photo" ‚Äî —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è
  * "drawing" ‚Äî —Ä–∏—Å—É–Ω–æ–∫, –≥—Ä–∞—Ñ–∏–∫–∞
  * "story" ‚Äî —Ä–∞—Å—Å–∫–∞–∑, –Ω–æ–≤–µ–ª–ª–∞

**–í–ê–ñ–ù–û:** –ü–æ–ª–µ "type" –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –°–¢–†–û–ì–û –æ–¥–Ω–∏–º –∏–∑ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π! –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π –¥—Ä—É–≥–∏–µ —Å–ª–æ–≤–∞!

–ü—Ä–∏–º–µ—Ä –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞:
{
  "works": [
    {"title": "–ó–≤—ë–∑–¥–Ω–∞—è –Ω–æ—á—å", "author": "–í–∏–Ω—Å–µ–Ω—Ç –í–∞–Ω –ì–æ–≥", "desc": "–ö–∞—Ä—Ç–∏–Ω–∞ –æ –∫–æ—Å–º–æ—Å–µ –∏ –æ–¥–∏–Ω–æ—á–µ—Å—Ç–≤–µ", "value": "", "type": "painting"},
    {"title": "–í–æ–π–Ω–∞ –∏ –º–∏—Ä", "author": "–õ–µ–≤ –¢–æ–ª—Å—Ç–æ–π", "desc": "–†–æ–º–∞–Ω –æ —Å—É–¥—å–±–∞—Ö –ª—é–¥–µ–π", "value": "", "type": "book"},
    {"title": "–ú–∞—Ç—Ä–∏—Ü–∞", "author": "–ë—Ä–∞—Ç—å—è –í–∞—á–æ–≤—Å–∫–∏", "desc": "–§–∏–ª—å–º –æ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏", "value": "", "type": "movie"}
  ]
}

–í–µ—Ä–Ω–∏ –æ—Ç–≤–µ—Ç —Å—Ç—Ä–æ–≥–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON, –±–µ–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –∏ –ª–∏—à–Ω–µ–≥–æ —Ç–µ–∫—Å—Ç–∞.`;

        const deepseekRequestBody = {
          model: 'deepseek-chat',
          messages: [
            { role: 'system', content: '–¢—ã —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –∏—Å–∫—É—Å—Å—Ç–≤—É. –û—Ç–≤–µ—á–∞–π —Ç–æ–ª—å–∫–æ –≤–∞–ª–∏–¥–Ω—ã–º JSON –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞.' },
            { role: 'user', content: prompt }
          ],
          max_tokens: 1500,
          temperature: 0.7,
          stream: false
        };

        const deepseekResponse = await fetch('https://api.deepseek.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${env.DEEPSEEK_API_KEY}`
          },
          body: JSON.stringify(deepseekRequestBody)
        });

        const responseBody = await deepseekResponse.json();
        let content = responseBody?.choices?.[0]?.message?.content || '{}';
        content = content.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();

        let parsed;
        try {
          parsed = JSON.parse(content);
        } catch {
          parsed = { works: [] };
        }

        const works = Array.isArray(parsed.works) ? parsed.works : [];
// –ü–æ—Å–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ similarArtworks:
// –ü–æ—Å–ª–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ similarArtworks:
const similarArtworksRaw = works.slice(0, 5).map(w => ({
  title: w.title || '',
  author: w.author || '',
  desc: w.desc || '',
  value: w.value || '',
  type: w.type || 'default'
}));

const { dreamId } = body;

let similarArtworks = [];

if (dreamId) {
  const d1 = env.DB;

  // ‚úÖ –£–î–ê–õ–Ø–ï–ú –°–¢–ê–†–´–ï –ó–ê–ü–ò–°–ò –ü–ï–†–ï–î –í–°–¢–ê–í–ö–û–ô –ù–û–í–´–•
  await d1.prepare(
    `DELETE FROM dream_similar_artworks WHERE dream_id = ?`
  ).bind(dreamId).run();

  for (let i = 0; i < similarArtworksRaw.length; i++) {
    const art = similarArtworksRaw[i];

    // 1) –ò—â–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞—ë–º artwork
    let artworkRow = await d1.prepare(
      `SELECT id FROM artworks WHERE title = ? AND author = ? AND type = ?`
    ).bind(art.title, art.author, art.type).first();

    let artworkId;
    if (artworkRow) {
      artworkId = artworkRow.id;
    } else {
      artworkId = crypto.randomUUID();
      await d1.prepare(
        `INSERT INTO artworks (id, title, author, type, value, desc)
         VALUES (?, ?, ?, ?, ?, ?)`
      ).bind(artworkId, art.title, art.author, art.type, art.value, art.desc).run();
    }

    // 2) –°–≤—è–∑—ã–≤–∞–µ–º —Å dream
    await d1.prepare(
      `INSERT INTO dream_similar_artworks (id, dream_id, artwork_id, position, score)
       VALUES (?, ?, ?, ?, ?)`
    ).bind(crypto.randomUUID(), dreamId, artworkId, i, null).run();

    // ‚úÖ –î–æ–±–∞–≤–ª—è–µ–º artworkId –≤ –æ–±—ä–µ–∫—Ç –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞
    similarArtworks.push({
      ...art,
      artworkId, // ‚úÖ –≤–æ—Ç —ç—Ç–æ –≤–∞–∂–Ω–æ!
    });
  }

  // 3) –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –æ–±–Ω–æ–≤–ª—è–µ–º dreams.similarArtworks –¥–ª—è –∫—ç—à–∞
  await d1.prepare(
    `UPDATE dreams SET similarArtworks = ? WHERE id = ? AND user = ?`
  ).bind(JSON.stringify(similarArtworks), dreamId, userEmail).run();
}

return new Response(JSON.stringify({ similarArtworks }), {
  status: 200,
  headers: { 'Content-Type': 'application/json', ...corsHeaders }
});

      } catch (e) {
        console.error('Error in /find_similar:', e);
        return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

 // --- Interpret block endpoint (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô) ---
if (url.pathname === '/interpret_block' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  if (!(await isTrialActive(userEmail, env))) {
    return new Response(JSON.stringify({ error: 'Trial expired' }), {
      status: 403, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const body = await request.json();
    const { blockText, dreamId, blockId, artworkId } = body;  // ‚úÖ artworkId —É–∂–µ –µ—Å—Ç—å

    if (!blockText) {
      return new Response(JSON.stringify({ error: 'No blockText' }), {
        status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const d1 = env.DB;
    let autoSummary = '';
    let dreamSummary = '';

    if (dreamId) {
      const dreamRow = await d1.prepare(
        `SELECT autoSummary, dreamSummary FROM dreams WHERE id = ? AND user = ?`
      ).bind(dreamId, userEmail).first();

      if (dreamRow) {
        autoSummary = dreamRow.autoSummary || '';
        dreamSummary = dreamRow.dreamSummary || '';
      }
    }

    const { rollingSummary, unprocessedMessages } = await getUnprocessedMessages(
      env,
      userEmail,
      dreamId,
      blockId,
      artworkId ?? null  // ‚úÖ –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ
    );

    let unprocessedContext = '';
    if (unprocessedMessages.length > 0) {
      unprocessedContext = '\n\n### –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–∏–∞–ª–æ–≥–∞ (–ø–æ—Å–ª–µ summary):\n';
      unprocessedMessages.forEach(msg => {
        const label = msg.role === 'user' ? '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å' : '–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç';
        unprocessedContext += `${label}: ${msg.content}\n`;
      });
    }

    const prompt = `${BLOCK_INTERPRETATION_PROMPT}

–í–´–ñ–ò–ú–ö–ê –°–ù–ê:
${autoSummary || '–ù–µ —É–∫–∞–∑–∞–Ω–∞'}

–°–£–ë–™–ï–ö–¢–ò–í–ù–´–ô –ö–û–ù–¢–ï–ö–°–¢ –û–¢ –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø:
${dreamSummary || '–ù–µ —É–∫–∞–∑–∞–Ω'}

–¢–ï–ö–£–©–ò–ô –ë–õ–û–ö:
${blockText.slice(0, 4000)}

ROLLING SUMMARY –î–ò–ê–õ–û–ì–ê:
${rollingSummary || '–î–∏–∞–ª–æ–≥ —Ç–æ–ª—å–∫–æ –Ω–∞—á–∞–ª—Å—è'}
${unprocessedContext}

–ù–∞ –æ—Å–Ω–æ–≤–µ –í–°–ï–ì–û –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ (–≤–∫–ª—é—á–∞—è –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è) –¥–∞–π —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞ —Å–Ω–∞.`;

    const deepseekRequestBody = {
      model: 'deepseek-chat',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 600,
      temperature: 0.7,
      stream: false
    };

    const deepseekResponse = await fetch('https://api.deepseek.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${env.DEEPSEEK_API_KEY}`
      },
      body: JSON.stringify(deepseekRequestBody)
    });

    const responseBody = await deepseekResponse.json();
    let interpretation = responseBody?.choices?.[0]?.message?.content || '';
    interpretation = interpretation.replace(/```[\s\S]*?```/g, '').replace(/^["'`]+|["'`]+$/g, '').trim();

    // üÜï –°–û–•–†–ê–ù–Ø–ï–ú —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ –±–ª–æ–∫–∞ –≤ messages —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º meta
    if (dreamId && blockId && interpretation) {
      const msgId = crypto.randomUUID();
      const createdAt = Date.now();

      await d1.prepare(
        `INSERT INTO messages (id, user, dream_id, block_id, role, content, created_at, meta, artwork_id)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`
      ).bind(
        msgId,
        userEmail,
        dreamId,
        blockId,
        'assistant',
        interpretation,
        createdAt,
        JSON.stringify({ kind: 'block_interpretation' }),
        artworkId ?? null  // ‚úÖ –°–æ—Ö—Ä–∞–Ω—è–µ–º artwork_id –µ—Å–ª–∏ –µ—Å—Ç—å
      ).run();

      // –¢–∞–∫–∂–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ blocks –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏
      const dreamRow = await d1.prepare(
        `SELECT blocks FROM dreams WHERE id = ? AND user = ?`
      ).bind(dreamId, userEmail).first();

      if (dreamRow) {
        let blocks = [];
        try {
          blocks = JSON.parse(dreamRow.blocks || '[]');
        } catch {
          blocks = [];
        }

        const blockIndex = blocks.findIndex(b => b.id === blockId);
        if (blockIndex !== -1) {
          blocks[blockIndex].interpretation = interpretation;

          await d1.prepare(
            `UPDATE dreams SET blocks = ? WHERE id = ? AND user = ?`
          ).bind(JSON.stringify(blocks), dreamId, userEmail).run();
        }
      }
    }

    return new Response(JSON.stringify({ 
      interpretation,
      isBlockInterpretation: true  // üÜï –§–ª–∞–≥ –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
    }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (e) {
    console.error('Error in /interpret_block:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- Interpret final endpoint (—Å rolling summary + –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ –≤—Å–µ–º –±–ª–æ–∫–∞–º) ---
if (url.pathname === '/interpret_final' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
  if (!(await isTrialActive(userEmail, env))) {
    return new Response(JSON.stringify({ error: 'Trial expired' }), {
      status: 403, headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const body = await request.json();
    const { dreamText, blocks, dreamId } = body;

    if (!dreamText) {
      return new Response(JSON.stringify({ error: 'No dreamText' }), {
        status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    // 1. –ó–∞–≥—Ä—É–∂–∞–µ–º autoSummary –∏ dreamSummary
    const d1 = env.DB;
    let autoSummary = '';
    let dreamSummary = '';

    if (dreamId) {
      const dreamRow = await d1.prepare(
        `SELECT autoSummary, dreamSummary FROM dreams WHERE id = ? AND user = ?`
      ).bind(dreamId, userEmail).first();

      if (dreamRow) {
        autoSummary = dreamRow.autoSummary || '';
        dreamSummary = dreamRow.dreamSummary || '';
      }
    }

    // 2. –°–æ–±–∏—Ä–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ –≤—Å–µ–º –±–ª–æ–∫–∞–º
    let blocksContext = '';
    if (dreamId && Array.isArray(blocks) && blocks.length > 0) {
      for (let i = 0; i < blocks.length; i++) {
        const block = blocks[i];
        const blockId = block.id;
        const blockText = block.text || block.content || "";
        
        // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–±—Ä–∞–ª–∏ artworkId (–∏—Ç–æ–≥–æ–≤–∞—è –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è ‚Äî –ø–æ —Å–Ω—É —Ü–µ–ª–∏–∫–æ–º)
        const { rollingSummary, unprocessedMessages } = await getUnprocessedMessages(
          env,
          userEmail,
          dreamId,
          blockId
        );

        blocksContext += `\n\n### –ë–ª–æ–∫ ${i + 1}:\n${blockText}\n`;

        if (rollingSummary) {
          blocksContext += `**–ö–æ–Ω—Ç–µ–∫—Å—Ç –¥–∏–∞–ª–æ–≥–∞ (summary):**\n${rollingSummary}\n`;
        }

        if (unprocessedMessages.length > 0) {
          blocksContext += `**–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è:**\n`;
          unprocessedMessages.forEach(msg => {
            const label = msg.role === 'user' ? '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å' : '–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç';
            blocksContext += `${label}: ${msg.content}\n`;
          });
        }
      }
    }

    // 3. –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç –¥–ª—è –∏—Ç–æ–≥–æ–≤–æ–≥–æ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏—è
    const prompt = `${FINAL_INTERPRETATION_PROMPT}

–í–´–ñ–ò–ú–ö–ê –°–ù–ê:
${autoSummary || '–ù–µ —É–∫–∞–∑–∞–Ω–∞'}

–°–£–ë–™–ï–ö–¢–ò–í–ù–´–ô –ö–û–ù–¢–ï–ö–°–¢ –û–¢ –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø:
${dreamSummary || '–ù–µ —É–∫–∞–∑–∞–Ω'}

–î–ò–ê–õ–û–ì–ò –ü–û –ë–õ–û–ö–ê–ú (–≤–∫–ª—é—á–∞—è –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è):
${blocksContext}

–°–æ–∑–¥–∞–π —Ü–µ–ª–æ—Å—Ç–Ω–æ–µ –∏—Ç–æ–≥–æ–≤–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ –≤—Å–µ–≥–æ —Å–Ω–∞, —É—á–∏—Ç—ã–≤–∞—è –≤–µ—Å—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–∏–∞–ª–æ–≥–æ–≤ (–≤–∫–ª—é—á–∞—è –ø–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è).`;

    const deepseekRequestBody = {
      model: 'deepseek-chat',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 800,
      temperature: 0.7,
      stream: false
    };

    const deepseekResponse = await fetch('https://api.deepseek.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${env.DEEPSEEK_API_KEY}`
      },
      body: JSON.stringify(deepseekRequestBody)
    });

    const responseBody = await deepseekResponse.json();
    let interpretation = responseBody?.choices?.[0]?.message?.content || '';
    interpretation = interpretation.replace(/```[\s\S]*?```/g, '').replace(/^["'`]+|["'`]+$/g, '').trim();

    // üÜï –°–û–•–†–ê–ù–Ø–ï–ú –∏—Ç–æ–≥–æ–≤–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ –≤ –ë–î
    if (dreamId && interpretation) {
      await d1.prepare(`
        UPDATE dreams 
        SET globalFinalInterpretation = ?
        WHERE id = ? AND user = ?
      `).bind(interpretation, dreamId, userEmail).run();
    }

    return new Response(JSON.stringify({ interpretation }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (e) {
    console.error('Error in /interpret_final:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- Interpret final for daily convo WITH CONTEXT ---
if (url.pathname === '/interpret_final_daily_convo' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const body = await request.json();
    const { notesText, dailyConvoId, blockId = 'main' } = body || {};

    if (!notesText || !dailyConvoId) {
      return new Response(JSON.stringify({ error: 'notesText and dailyConvoId required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const d1 = env.DB;
    
    // 1. –ü–æ–ª—É—á–∞–µ–º autoSummary
    let autoSummary = '';
    const dailyRow = await d1.prepare(
      'SELECT autoSummary FROM daily_convos WHERE id = ? AND user = ?'
    ).bind(dailyConvoId, userEmail).first();
    
    if (dailyRow) {
      autoSummary = dailyRow.autoSummary || '';
    }

    // 2. –ü–æ–ª—É—á–∞–µ–º rolling summary + –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    const { rollingSummary, unprocessedMessages } = await getUnprocessedMessages(
      env, userEmail, dailyConvoId, blockId
    );

    let unprocessedContext = '';
    if (unprocessedMessages.length > 0) {
      unprocessedContext = '\n\n### –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–∏–∞–ª–æ–≥–∞:\n';
      unprocessedMessages.forEach(msg => {
        const label = msg.role === 'user' ? '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å' : '–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç';
        unprocessedContext += `${label}: ${msg.content}\n`;
      });
    }

    // 3. –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç
    const prompt = `${FINAL_INTERPRETATION_PROMPT_DAILY}

–í–´–ñ–ò–ú–ö–ê –ó–ê–ü–ò–°–ò:
${autoSummary || '–ù–µ —É–∫–∞–∑–∞–Ω–∞'}

–¢–ï–ö–°–¢ –ó–ê–ü–ò–°–ò:
${notesText.slice(0, 4000)}

–ö–û–ù–¢–ï–ö–°–¢ –î–ò–ê–õ–û–ì–ê (ROLLING SUMMARY):
${rollingSummary || '–î–∏–∞–ª–æ–≥ —Ç–æ–ª—å–∫–æ –Ω–∞—á–∞–ª—Å—è'}
${unprocessedContext}

–°–æ–∑–¥–∞–π —Ü–µ–ª–æ—Å—Ç–Ω–æ–µ –∏—Ç–æ–≥–æ–≤–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ, —É—á–∏—Ç—ã–≤–∞—è –≤–µ—Å—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–∏–∞–ª–æ–≥–∞.`;

    const deepseekRequestBody = {
      model: 'deepseek-chat',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 800,
      temperature: 0.7,
      stream: false
    };

    const deepseekResponse = await fetch('https://api.deepseek.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${env.DEEPSEEK_API_KEY}`
      },
      body: JSON.stringify(deepseekRequestBody)
    });

    const responseBody = await deepseekResponse.json();
    let interpretation = responseBody?.choices?.[0]?.message?.content || '';
    interpretation = interpretation.replace(/```[\s\S]*?```/g, '').replace(/^["'`]+|["'`]+$/g, '').trim();

    // 4. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
    if (interpretation) {
      await d1.prepare(
        `UPDATE daily_convos SET globalFinalInterpretation = ? WHERE id = ? AND user = ?`
      ).bind(interpretation, dailyConvoId, userEmail).run();
    }

    return new Response(JSON.stringify({ interpretation }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (err) {
    console.error('Error in /interpret_final_daily_convo:', err);
    return new Response(JSON.stringify({ error: 'internal_error', message: err?.message || String(err) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- Interpret block for daily convo ---
if (url.pathname === '/interpret_block_daily_convo' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const ct = request.headers.get('content-type') || '';
    if (!ct.includes('application/json')) {
      return new Response(JSON.stringify({ error: 'Invalid content type' }), {
        status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const body = await request.json();
    const { notesText, blockType = 'dialog' } = body || {};

    if (!notesText || typeof notesText !== 'string') {
      return new Response(JSON.stringify({ error: 'No notesText' }), {
        status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const interpretation = await interpretBlock(env, notesText, blockType);

    return new Response(JSON.stringify({ interpretation }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (err) {
    console.error('Error in /interpret_block_daily_convo:', err);
    return new Response(JSON.stringify({ error: 'internal_error', message: err?.message || String(err) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- Interpret block for daily convo WITH CONTEXT ---
if (url.pathname === '/interpret_block_daily_convo_context' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const body = await request.json();
    const { notesText, dailyConvoId, blockId = 'main' } = body || {};

    if (!notesText || !dailyConvoId) {
      return new Response(JSON.stringify({ error: 'notesText and dailyConvoId required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    // 1. –ü–æ–ª—É—á–∞–µ–º autoSummary
    const d1 = env.DB;
    let autoSummary = '';
    const dailyRow = await d1.prepare(
      'SELECT autoSummary FROM daily_convos WHERE id = ? AND user = ?'
    ).bind(dailyConvoId, userEmail).first();
    
    if (dailyRow) {
      autoSummary = dailyRow.autoSummary || '';
    }

    // 2. –ü–æ–ª—É—á–∞–µ–º rolling summary + –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    const { rollingSummary, unprocessedMessages } = await getUnprocessedMessages(
      env, userEmail, dailyConvoId, blockId
    );

    let unprocessedContext = '';
    if (unprocessedMessages.length > 0) {
      unprocessedContext = '\n\n### –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–∏–∞–ª–æ–≥–∞:\n';
      unprocessedMessages.forEach(msg => {
        const label = msg.role === 'user' ? '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å' : '–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç';
        unprocessedContext += `${label}: ${msg.content}\n`;
      });
    }

    // 3. –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç
    const prompt = `${BLOCK_INTERPRETATION_PROMPT_DAILY}

–í–´–ñ–ò–ú–ö–ê –ó–ê–ü–ò–°–ò:
${autoSummary || '–ù–µ —É–∫–∞–∑–∞–Ω–∞'}

–¢–ï–ö–£–©–ò–ô –¢–ï–ö–°–¢:
${notesText.slice(0, 4000)}

ROLLING SUMMARY –î–ò–ê–õ–û–ì–ê:
${rollingSummary || '–î–∏–∞–ª–æ–≥ —Ç–æ–ª—å–∫–æ –Ω–∞—á–∞–ª—Å—è'}
${unprocessedContext}

–ù–∞ –æ—Å–Ω–æ–≤–µ –í–°–ï–ì–û –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –¥–∞–π —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç–æ–µ —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ.`;

    const deepseekRequestBody = {
      model: 'deepseek-chat',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 600,
      temperature: 0.7,
      stream: false
    };

    const deepseekResponse = await fetch('https://api.deepseek.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${env.DEEPSEEK_API_KEY}`
      },
      body: JSON.stringify(deepseekRequestBody)
    });

    const responseBody = await deepseekResponse.json();
    let interpretation = responseBody?.choices?.[0]?.message?.content || '';
    interpretation = interpretation.replace(/```[\s\S]*?```/g, '').replace(/^["'`]+|["'`]+$/g, '').trim();

    // 4. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª–∫–æ–≤–∞–Ω–∏–µ –≤ messages
    const msgId = crypto.randomUUID();
    const createdAt = Date.now();

    await d1.prepare(
      `INSERT INTO messages (id, user, dream_id, block_id, role, content, created_at, meta)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`
    ).bind(
      msgId,
      userEmail,
      dailyConvoId,
      blockId,
      'assistant',
      interpretation,
      createdAt,
      JSON.stringify({ kind: 'daily_block_interpretation' })
    ).run();

    return new Response(JSON.stringify({ 
      interpretation,
      isBlockInterpretation: true
    }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (err) {
    console.error('Error in /interpret_block_daily_convo_context:', err);
    return new Response(JSON.stringify({ error: 'internal_error', message: err?.message || String(err) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- Interpret final for daily convo (NEW) ---
if (url.pathname === '/interpret_final_daily_convo_new' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  try {
    const ct = request.headers.get('content-type') || '';
    if (!ct.includes('application/json')) {
      return new Response(JSON.stringify({ error: 'Invalid content type' }), {
        status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const body = await request.json();
    const { notesText, blockType = 'dialog' } = body || {};

    if (!notesText || typeof notesText !== 'string') {
      return new Response(JSON.stringify({ error: 'No notesText' }), {
        status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const interpretation = await interpretFinal(env, notesText, blockType);

    return new Response(JSON.stringify({ interpretation }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (err) {
    console.error('Error in /interpret_final_daily_convo_new:', err);
    return new Response(JSON.stringify({ error: 'internal_error', message: err?.message || String(err) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- ART CHAT: GET /art_chat?artDialogId=...&artworkId=...&blockId=... ---
if (url.pathname === '/art_chat' && request.method === 'GET') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const dreamId = url.searchParams.get('dreamId');    // ‚úÖ —á–∏—Å—Ç—ã–π UUID
  const artworkId = url.searchParams.get('artworkId');
  const blockId = url.searchParams.get('blockId');

  if (!dreamId || !blockId) {
    return new Response(JSON.stringify({ error: 'Missing dreamId or blockId' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  try {
    let query = `
      SELECT id, role, content, created_at, meta
      FROM messages
      WHERE user = ? AND dream_id = ? AND block_id = ?
    `;
    const params = [userEmail, dreamId, blockId];

    // ‚úÖ –ï—Å–ª–∏ –µ—Å—Ç—å artworkId ‚Äî —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –Ω–µ–º—É
    if (artworkId) {
      query += ` AND artwork_id = ?`;
      params.push(artworkId);
    }

    query += ` ORDER BY created_at ASC`;

    const res = await env.DB.prepare(query).bind(...params).all();

    const messages = (res.results || []).map((r) => ({
      id: r.id,
      role: r.role,
      content: r.content,
      created_at: r.created_at,
      meta: r.meta ? JSON.parse(r.meta) : undefined,
    }));

    return new Response(JSON.stringify({ messages }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  } catch (e) {
    console.error('GET /art_chat error', e);
    return new Response(
      JSON.stringify({ error: 'internal_error', details: e?.message || String(e) }),
      { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders } }
    );
  }
}

// --- POST /art_chat ---
if (url.pathname === '/art_chat' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  let body;
  try {
    body = await request.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const { id, dreamId, blockId, artworkId, role, content, meta } = body || {};
  
  if (!dreamId || !blockId || !role || !content || !['user', 'assistant'].includes(role)) {
    return new Response(JSON.stringify({ error: 'Invalid payload' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const msgId = id || crypto.randomUUID();
  const createdAt = Date.now();

  try {
    await env.DB.prepare(
      `INSERT INTO messages (id, user, dream_id, block_id, role, content, created_at, meta, artwork_id)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`
    )
    .bind(
      msgId,
      userEmail,
      dreamId,        // ‚úÖ —á–∏—Å—Ç—ã–π UUID —Å–Ω–∞
      blockId,
      role,
      String(content).slice(0, 12000),
      createdAt,
      meta ? JSON.stringify(meta) : null,
      artworkId || null
    )
    .run();

    // Rolling summary
    if (role === 'assistant') {
      try {
        let artworkText = '';
        if (artworkId) {
          const artworkRow = await env.DB.prepare(
            `SELECT title, author, desc FROM artworks WHERE id = ?`
          ).bind(artworkId).first();

          if (artworkRow) {
            artworkText = `${artworkRow.title} ‚Äî ${artworkRow.author}\n${artworkRow.desc}`;
          }
        }

        await updateRollingSummary(
          env,
          userEmail,
          dreamId,        // ‚úÖ —á–∏—Å—Ç—ã–π UUID
          blockId,
          artworkText,
          env.DEEPSEEK_API_KEY,
          artworkId || null
        );
      } catch (e) {
        console.warn('[POST /art_chat] Failed to update summary:', e);
      }
    }

    return new Response(
      JSON.stringify({
        id: msgId,
        role,
        content,
        created_at: createdAt,
        meta: meta ?? null,
      }),
      {
        status: 201,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      }
    );
  } catch (e) {
    console.error('POST /art_chat error', e);
    return new Response(
      JSON.stringify({ error: 'internal_error', details: e?.message || String(e) }),
      { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders } }
    );
  }
}

// --- GET /dreams/:dreamId/similar_artworks ---
if (url.pathname.match(/^\/dreams\/[^/]+\/similar_artworks$/) && request.method === 'GET') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const dreamId = url.pathname.split('/')[2];

  try {
    const res = await env.DB.prepare(
      `SELECT 
         a.id as artwork_id,
         a.title,
         a.author,
         a.type,
         a.value,
         a.desc,
         dsa.position,
         dsa.score
       FROM dream_similar_artworks dsa
       JOIN artworks a ON a.id = dsa.artwork_id
       WHERE dsa.dream_id = ?
       ORDER BY dsa.position ASC`
    ).bind(dreamId).all();

    const artworks = (res.results || []).map((r) => ({
      artwork_id: r.artwork_id,
      title: r.title,
      author: r.author,
      type: r.type,
      value: r.value,
      desc: r.desc,
      position: r.position,
      score: r.score,
    }));

    return new Response(JSON.stringify({ artworks }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  } catch (e) {
    console.error('GET /dreams/:dreamId/similar_artworks error', e);
    return new Response(
      JSON.stringify({ error: 'internal_error', details: e?.message || String(e) }),
      { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders } }
    );
  }
}

// --- Interpret block for art WITH CONTEXT ---
if (url.pathname === '/interpret_block_art' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  try {
    const body = await request.json();
    const { dreamId, blockId, artworkId } = body || {};

    if (!dreamId || !blockId) {
      return new Response(
        JSON.stringify({ error: 'dreamId and blockId required' }),
        { status: 400, headers: { 'Content-Type': 'application/json', ...corsHeaders } }
      );
    }

    let artworkRow = null;

    if (artworkId) {
      artworkRow = await env.DB.prepare(
        `SELECT title, author, type, value, desc FROM artworks WHERE id = ?`
      ).bind(artworkId).first();
    } else if (blockId && blockId.startsWith('artwork__')) {
      const match = blockId.match(/^artwork__(\d+)$/);
      if (match) {
        const artIndex = parseInt(match[1], 10);

        const dreamRow = await env.DB.prepare(
          `SELECT similarArtworks FROM dreams WHERE id = ?`
        ).bind(dreamId).first();

        if (dreamRow && dreamRow.similarArtworks) {
          let similarArtworks = [];
          try {
            similarArtworks = JSON.parse(dreamRow.similarArtworks);
          } catch {}

          const artwork = similarArtworks[artIndex];
          if (artwork) {
            artworkRow = {
              title: artwork.title || '',
              author: artwork.author || '',
              type: artwork.type || 'default',
              value: artwork.value || '',
              desc: artwork.desc || '',
            };
          }
        }
      }
    }

    if (!artworkRow) {
      return new Response(
        JSON.stringify({ error: 'Artwork not found' }),
        { status: 404, headers: { 'Content-Type': 'application/json', ...corsHeaders } }
      );
    }

    const artworkText = `
–ù–∞–∑–≤–∞–Ω–∏–µ: ${artworkRow.title}
–ê–≤—Ç–æ—Ä: ${artworkRow.author}
–¢–∏–ø: ${artworkRow.type}
–û–ø–∏—Å–∞–Ω–∏–µ: ${artworkRow.desc}
`.trim();

    // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –¥–æ–±–∞–≤–∏–ª–∏ artworkId –¥–ª—è —Å—Ç—Ä–æ–≥–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ø–æ artwork
    const { rollingSummary, unprocessedMessages } = await getUnprocessedMessages(
      env,
      userEmail,
      dreamId,
      blockId,
      artworkId || null  // ‚úÖ –¢–µ–ø–µ—Ä—å –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å—Ç—Ä–æ–≥–æ –ø–æ artwork
    );

    let unprocessedContext = '';
    if (unprocessedMessages.length > 0) {
      unprocessedContext = '\n\n–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–∏–∞–ª–æ–≥–∞:\n';
      unprocessedMessages.forEach((msg) => {
        const label = msg.role === 'user' ? '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å' : '–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç';
        unprocessedContext += `${label}: ${msg.content}\n`;
      });
    }

    const userPrompt = `
${ART_BLOCK_INTERPRETATION_PROMPT}

---

–û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è (artwork):
${artworkText.slice(0, 4000)}

---

–ö—Ä–∞—Ç–∫–æ–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –¥–∏–∞–ª–æ–≥–∞ (rolling summary):
${rollingSummary || '–î–∏–∞–ª–æ–≥ —Ç–æ–ª—å–∫–æ –Ω–∞—á–∞–ª—Å—è, –ø–æ–¥—Ä–æ–±–Ω–æ–≥–æ —Ä–µ–∑—é–º–µ –µ—â—ë –Ω–µ—Ç.'}

${unprocessedContext}
`.trim();

    const deepseekRequestBody = {
      model: 'deepseek-chat',
      messages: [
        {
          role: 'system',
          content: '–¢—ã –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã–π –ø—Å–∏—Ö–æ–ª–æ–≥ –∏ –∞—Ä—Ç-—Ç–µ—Ä–∞–ø–µ–≤—Ç. –û—Ç–≤–µ—á–∞–π –≤—Å–µ–≥–¥–∞ –Ω–∞ —Ä—É—Å—Å–∫–æ–º, –∂–∏–≤—ã–º —á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏–º —è–∑—ã–∫–æ–º.',
        },
        { role: 'user', content: userPrompt },
      ],
      max_tokens: 800,
      temperature: 0.7,
      stream: false,
    };

    const deepseekResponse = await fetch(
      'https://api.deepseek.com/v1/chat/completions',
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${env.DEEPSEEK_API_KEY}`,
        },
        body: JSON.stringify(deepseekRequestBody),
      },
    );

    if (!deepseekResponse.ok) {
      const errText = await deepseekResponse.text().catch(() => '');
      console.error('DeepSeek /interpret_block_art error', deepseekResponse.status, errText);
      throw new Error(`DeepSeek error: ${deepseekResponse.status}`);
    }

    const responseBody = await deepseekResponse.json();

    let interpretation =
      responseBody?.choices?.[0]?.message?.content || '';

    interpretation = interpretation
      .replace(/```[\s\S]*?```/g, '')
      .replace(/^["'`]+|["'`]+$/g, '')
      .trim();

    if (!interpretation) {
      interpretation =
        '–ú–Ω–µ –Ω–µ —É–¥–∞–ª–æ—Å—å —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç—É—é –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—é, –Ω–æ —ç—Ç–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —è–≤–Ω–æ –Ω–µ—Å—ë—Ç –≤–∞–∂–Ω—ã–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —Å–º—ã—Å–ª. –ü–æ–ø—Ä–æ–±—É–π –∑–∞–¥–∞—Ç—å –µ—â—ë –æ–¥–∏–Ω –≤–æ–ø—Ä–æ—Å –∏–ª–∏ —É—Ç–æ—á–Ω–∏—Ç—å, —á—Ç–æ —Ç—ã —á—É–≤—Å—Ç–≤—É–µ—à—å, –≥–ª—è–¥—è –Ω–∞ –Ω–µ–≥–æ.';
    }

    const msgId = crypto.randomUUID();
    const createdAt = Date.now();

    await env.DB.prepare(
      `INSERT INTO messages (id, user, dream_id, block_id, role, content, created_at, meta, artwork_id)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`
    )
      .bind(
        msgId,
        userEmail,
        dreamId,
        blockId,
        'assistant',
        interpretation,
        createdAt,
        JSON.stringify({ kind: 'art_block_interpretation' }),
        artworkId || null
      )
      .run();

    return new Response(
      JSON.stringify({
        interpretation,
        isBlockInterpretation: true,
      }),
      {
        status: 200,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      },
    );
  } catch (err) {
    console.error('Error in /interpret_block_art:', err);
    return new Response(
      JSON.stringify({
        error: 'internal_error',
        message: err?.message || String(err),
      }),
      {
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      },
    );
  }
}

// --- DELETE /art_chat ---
if (url.pathname === '/art_chat' && request.method === 'DELETE') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  let body;
  try {
    body = await request.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const { dreamId, blockId, artworkId } = body || {};

  if (!dreamId || !blockId) {
    return new Response(JSON.stringify({ error: 'Missing dreamId or blockId' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  try {
    let deleteMessagesQuery = `DELETE FROM messages WHERE user = ? AND dream_id = ? AND block_id = ?`;
    let deleteSummariesQuery = `DELETE FROM dialog_summaries WHERE user = ? AND dream_id = ? AND block_id = ?`;
    const params = [userEmail, dreamId, blockId];

    if (artworkId) {
      deleteMessagesQuery += ` AND artwork_id = ?`;
      deleteSummariesQuery += ` AND artwork_id = ?`;
      params.push(artworkId);
    }

    await env.DB.prepare(deleteMessagesQuery).bind(...params).run();
    await env.DB.prepare(deleteSummariesQuery).bind(...params).run();

    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  } catch (e) {
    console.error('DELETE /art_chat error', e);
    return new Response(
      JSON.stringify({ error: 'internal_error', details: e?.message || String(e) }),
      { status: 500, headers: { 'Content-Type': 'application/json', ...corsHeaders } }
    );
  }
}



// --- Dashboard metrics endpoint (–Ω–æ—Ä–º–∞–ª—å–Ω—ã–π range) ---
if (url.pathname === '/dashboard' && request.method === 'GET') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

  if (!(await isTrialActive(userEmail, env))) {
    return new Response(JSON.stringify({ error: 'Trial expired' }), {
      status: 403,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }

try {
    const d1 = env.DB;

    // ‚úÖ –û–ü–†–ï–î–ï–õ–Ø–ï–ú –§–£–ù–ö–¶–ò–Æ –°–†–ê–ó–£
    function resolveSinceTs(range) {
      const now = Date.now();
      let sinceTs;

      switch (range) {
        case '7d':   sinceTs = now - (7  * 24 * 60 * 60 * 1000); break;
        case '30d':  sinceTs = now - (30 * 24 * 60 * 60 * 1000); break;
        case '60d':  sinceTs = now - (60 * 24 * 60 * 60 * 1000); break;
        case '90d':  sinceTs = now - (90 * 24 * 60 * 60 * 1000); break;
        case '365d': sinceTs = now - (365 * 24 * 60 * 60 * 1000); break;
        case 'all':  sinceTs = 0; break;
        default:     sinceTs = now - (30 * 24 * 60 * 60 * 1000); break;
      }

      const date = new Date(sinceTs);
      date.setUTCHours(0, 0, 0, 0);
      sinceTs = date.getTime();

      console.log(`[resolveSinceTs] range=${range}, sinceTs=${sinceTs}, date=${new Date(sinceTs).toISOString()}`);
      return sinceTs;
    }

  // ---------- –ë–õ–û–ö RANGE ----------
    const rangeParamRaw = url.searchParams.get('range') || '30d';
    const allowedRanges = ['7d','30d','60d','90d','365d','all'];
    const rangeParam = (allowedRanges.includes(rangeParamRaw) ? rangeParamRaw : '30d');

    const isAll = rangeParam === 'all';

    // ‚úÖ –í–´–ó–´–í–ê–ï–ú –§–£–ù–ö–¶–ò–Æ –ò –°–û–•–†–ê–ù–Ø–ï–ú –†–ï–ó–£–õ–¨–¢–ê–¢
    const sinceTs = resolveSinceTs(rangeParam);
    const thirtyDaysAgo = resolveSinceTs('30d');

    // –í—Å–µ–≥–æ —Å–Ω–æ–≤
    const totalDreamsRow = await d1
      .prepare('SELECT COUNT(*) AS count FROM dreams WHERE user = ?')
      .bind(userEmail)
      .first();
    const totalDreams = Number(totalDreamsRow?.count || 0);

    // –ë–ª–æ–∫–æ–≤ (–¥–∏–∞–ª–æ–≥–æ–≤) –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 30 –¥–Ω–µ–π ‚Äî –ù–ï –∑–∞–≤–∏—Å–∏—Ç –æ—Ç range
    const monthlyBlocksRow = await d1
      .prepare(
        `SELECT COUNT(DISTINCT dream_id) AS count
         FROM messages
         WHERE user = ? AND created_at > ?`
      )
      .bind(userEmail, thirtyDaysAgo)
      .first();
    const monthlyBlocks = Number(monthlyBlocksRow?.count || 0);

    // –°–Ω–æ–≤ —Å —Ñ–∏–Ω–∞–ª—å–Ω–æ–π –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–µ–π (all‚Äëtime)
    const interpretedRow = await d1
      .prepare(
        `SELECT COUNT(*) AS count
         FROM dreams
         WHERE user = ?
           AND globalFinalInterpretation IS NOT NULL
           AND globalFinalInterpretation != ''`
      )
      .bind(userEmail)
      .first();
    const interpretedCount = Number(interpretedRow?.count || 0);

    // –°–Ω–æ–≤ —Å –∞—Ä—Ç–∞–º–∏ (all‚Äëtime)
    const artworksRow = await d1
      .prepare(
        `SELECT COUNT(*) AS count
         FROM dreams
         WHERE user = ?
           AND similarArtworks IS NOT NULL
           AND similarArtworks NOT IN ('[]','{}')`
      )
      .bind(userEmail)
      .first();
    const artworksCount = Number(artworksRow?.count || 0);

    // –°–Ω–æ–≤ —Å –¥–∏–∞–ª–æ–≥–∞–º–∏ (all‚Äëtime)
const dialogDreamsRow = await d1
  .prepare(
    `SELECT COUNT(DISTINCT dream_id) AS count
     FROM messages
     WHERE user = ? AND role = 'assistant'
       AND dream_id IN (SELECT id FROM dreams WHERE user = ?)`
  )
  .bind(userEmail, userEmail)
  .first();
const dialogDreamsCount = Number(dialogDreamsRow?.count || 0);

    // ---------- –°—Ç—Ä–∏–∫ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –≥–æ–¥ (–Ω–µ–∑–∞–≤–∏—Å–∏–º –æ—Ç range) ----------
    const streakSinceTs = Date.now() - 365 * 24 * 60 * 60 * 1000;
    const streakStmt = await d1
      .prepare(
        `SELECT DATE(date/1000, 'unixepoch') AS day,
                COUNT(*) AS count
         FROM dreams
         WHERE user = ? AND date > ?
         GROUP BY day
         ORDER BY day DESC`
      )
      .bind(userEmail, streakSinceTs)
      .all();

    const dailyDreams = streakStmt.results || [];
    let streak = 0;
    let currentDate = new Date();
    currentDate.setHours(0, 0, 0, 0);

    for (let i = 0; i < dailyDreams.length; i++) {
      const dreamDate = new Date(dailyDreams[i].day);
      dreamDate.setHours(0, 0, 0, 0);

      if (i === 0) {
        const diffDays =
          (currentDate.getTime() - dreamDate.getTime()) / (1000 * 60 * 60 * 24);
        if (diffDays <= 1) {
          streak = 1;
          currentDate = dreamDate;
        } else {
          break;
        }
      } else {
        const expectedDate = new Date(currentDate);
        expectedDate.setDate(expectedDate.getDate() - 1);
        if (dreamDate.getTime() === expectedDate.getTime()) {
          streak++;
          currentDate = dreamDate;
        } else {
          break;
        }
      }
    }

    // 7) –î–∞–Ω–Ω—ã–µ –¥–ª—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ (–∫–∞–∫ –±—ã–ª–æ)
    const interpretedForScoreResult = await d1.prepare(
      `SELECT COUNT(*) as count 
       FROM dreams 
       WHERE user = ? AND globalFinalInterpretation IS NOT NULL AND globalFinalInterpretation != ''`
    ).bind(userEmail).first();

    const summarizedForScoreResult = await d1.prepare(
      `SELECT COUNT(*) as count 
       FROM dreams 
       WHERE user = ? AND dreamSummary IS NOT NULL AND dreamSummary != ''`
    ).bind(userEmail).first();

    const maxLengthResult = await d1.prepare(
      `SELECT MAX(LENGTH(globalFinalInterpretation)) as maxLength 
       FROM dreams 
       WHERE user = ? AND globalFinalInterpretation IS NOT NULL`
    ).bind(userEmail).first();

    const maxLength = maxLengthResult?.maxLength || 0;

    const progressData = {
      total_dreams: totalDreams,
      interpreted_count: interpretedForScoreResult?.count || 0,
      summarized_count: summarizedForScoreResult?.count || 0,
      artworks_count: artworksCount,
      max_interpretation_length: maxLength
    };

    // 8) –ë–∞–∑–æ–≤—ã–π –æ–±—â–∏–π score (–∏—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞—à—É —Ñ—É–Ω–∫—Ü–∏—é)
    const improvementScore = calculateImprovementScore(progressData);

    // ------------------------------
    // 9) –ù–æ–≤–∞—è –ª–æ–≥–∏–∫–∞: –∏—Å—Ç–æ—Ä–∏—è (history), score/scoreDelta, highest, breakdown, recentDreams
    // ------------------------------

    // 9.1 Aggregation per day (GROUP BY day) within requested period (or all)
    const aggSql = `
      SELECT
        DATE(date/1000, 'unixepoch') as day,
        MIN(date) as day_first_ts,
        COUNT(*) as total,
        SUM(CASE WHEN globalFinalInterpretation IS NOT NULL AND globalFinalInterpretation != '' THEN 1 ELSE 0 END) as interpreted,
        SUM(CASE WHEN dreamSummary IS NOT NULL AND dreamSummary != '' THEN 1 ELSE 0 END) as summarized,
        SUM(CASE WHEN similarArtworks IS NOT NULL AND similarArtworks != '' AND similarArtworks != '[]' THEN 1 ELSE 0 END) as artworks,
        SUM(CASE WHEN EXISTS (SELECT 1 FROM messages m WHERE m.user = dreams.user AND m.dream_id = dreams.id AND m.role = 'assistant') THEN 1 ELSE 0 END) as dialogs
      FROM dreams
      WHERE user = ? ${isAll ? "" : "AND date >= ?"}
      GROUP BY day
      ORDER BY day ASC
    `;

    const aggStmt = isAll 
      ? d1.prepare(aggSql).bind(userEmail) 
      : d1.prepare(aggSql).bind(userEmail, sinceTs);
    const aggRes = await aggStmt.all();
    const aggRows = aggRes.results || [];

    // 9.2 Build cumulative history (cumulative up-to-day). If you prefer per-day snapshots, use row values directly.
    let cumulative = { total: 0, interpreted: 0, summarized: 0, artworks: 0, dialogs: 0 };
    const history = [];

    // Helper: compute score for given cumulative aggregation. Prefer existing calculateImprovementScore if available.
    function computeScoreFromAgg(agg) {
      try {
        if (typeof calculateImprovementScore === 'function') {
          // CalculateImprovementScore expects an object; try passing compatible shape
          const dataForCalc = {
            total_dreams: agg.total || 0,
            interpreted_count: agg.interpreted || 0,
            summarized_count: agg.summarized || 0,
            artworks_count: agg.artworks || 0,
            max_interpretation_length: maxLength // reuse overall max length as proxy
          };
          return Math.round(calculateImprovementScore(dataForCalc));
        }
      } catch (e) {
        // fall back
      }

      // Fallback heuristic if calculateImprovementScore unavailable
      const total = agg.total || 1;
      const interpretedPct = (agg.interpreted || 0) / total;
      const dialogPct = (agg.dialogs || 0) / total;
      const artworkPct = (agg.artworks || 0) / total;
      const score = Math.round(Math.min(100, 100 * (0.55 * interpretedPct + 0.25 * dialogPct + 0.20 * artworkPct)));
      return score;
    }

    for (const r of aggRows) {
      cumulative.total += Number(r.total || 0);
      cumulative.interpreted += Number(r.interpreted || 0);
      cumulative.summarized += Number(r.summarized || 0);
      cumulative.artworks += Number(r.artworks || 0);
      cumulative.dialogs += Number(r.dialogs || 0);

      const point = {
        date: new Date(Number(r.day_first_ts || r.day)).toISOString(),
        score: computeScoreFromAgg(cumulative),
        counts: { ...cumulative }
      };
      history.push(point);
    }

   // ‚úÖ –ï—Å–ª–∏ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ –ø–µ—Ä–∏–æ–¥ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤
if (history.length === 0) {
  // –ù–ï –¥–æ–±–∞–≤–ª—è–µ–º —Ñ–µ–π–∫–æ–≤—É—é —Ç–æ—á–∫—É ‚Äî –ø—É—Å—Ç—å —Ñ—Ä–æ–Ω—Ç —Å–∞–º —Ä–µ—à–∞–µ—Ç, —á—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å
  console.warn(`[dashboard] No history data for range=${rangeParam}`);
}

    // 9.3 Build historyOut (date + score)
    const historyOut = history.map(h => ({ date: h.date, score: h.score }));

    // 9.4 score, scoreDelta, highestScore
    const lastScore = historyOut.length ? historyOut[historyOut.length - 1].score : Math.round(improvementScore || 0);
    const prevScore = historyOut.length > 1 ? historyOut[historyOut.length - 2].score : null;
    const scoreDelta = prevScore === null ? 0 : lastScore - prevScore;
    const highestPoint = historyOut.reduce((acc, p) => (acc === null || p.score > acc.score ? p : acc), null);

    // 9.5 recentDreams (last N)
    // ---------- recentDreams (–∑–∞ –ø–µ—Ä–∏–æ–¥ / all) ----------
    // ---------- recentDreams (–∑–∞ –ø–µ—Ä–∏–æ–¥ / all) ----------
// ‚úÖ –í—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 12 —Å–Ω–æ–≤ (–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç range)
const recentLimit = 12;
const recentSql = `
  SELECT id, title, date,
    (globalFinalInterpretation IS NOT NULL AND globalFinalInterpretation != '') AS interpreted
  FROM dreams
  WHERE user = ?
  ORDER BY date DESC
  LIMIT ?
`;

const recentStmt = d1.prepare(recentSql).bind(userEmail, recentLimit);
const recentRes = await recentStmt.all();

const recentDreams = (recentRes.results || []).map((r) => ({
  id: r.id,
  title: r.title || null,
  date: new Date(Number(r.date)).toISOString(),
  interpreted: Boolean(r.interpreted),
}));

    // 9.6 breakdownCounts & breakdownPercent (from final cumulative)
    const finalCounts = history.length ? history[history.length - 1].counts : { total: 0, interpreted: 0, summarized: 0, artworks: 0, dialogs: 0 };
    const breakdownCounts = {
      interpreted: finalCounts.interpreted || 0,
      summarized: finalCounts.summarized || 0,
      artworks: finalCounts.artworks || 0,
      dialogs: finalCounts.dialogs || 0
    };
    const totalForPct = Math.max(1, finalCounts.total || 0);
    const totalDreamsInPeriod = finalCounts.total || 0;
    const breakdownPercent = {
      interpreted: Math.round((breakdownCounts.interpreted / totalForPct) * 100),
      summarized: Math.round((breakdownCounts.summarized / totalForPct) * 100),
      artworks: Math.round((breakdownCounts.artworks / totalForPct) * 100),
      dialogs: Math.round((breakdownCounts.dialogs / totalForPct) * 100)
    };

    // =============================
    // ‚úÖ –ê–ì–†–ï–ì–ê–¶–ò–Ø –ù–ê–°–¢–†–û–ï–ù–ò–ô –° –£–ß–Å–¢–û–ú –ü–ï–†–ò–û–î–ê
    // =============================

    let moodCounts = {};
    let moodTotal = 0;

    try {
      const moodsSql = isAll
  ? `SELECT context, COUNT(*) AS cnt FROM moods WHERE user_email = ? GROUP BY context`
  : `SELECT context, COUNT(*) AS cnt 
     FROM moods 
     WHERE user_email = ? 
       AND date >= ?  -- ‚úÖ –£–±–∏—Ä–∞–µ–º date(), —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –Ω–∞–ø—Ä—è–º—É—é
     GROUP BY context`;

const moodsStmt = isAll
  ? d1.prepare(moodsSql).bind(userEmail)
  : d1.prepare(moodsSql).bind(userEmail, sinceTs); // ‚úÖ –ü–µ—Ä–µ–¥–∞—ë–º –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥—ã –Ω–∞–ø—Ä—è–º—É—é

      const moodsRes = await moodsStmt.all();
      const moodRows = moodsRes?.results ?? [];

      for (const r of moodRows) {
        const key = r.context ?? 'unknown';
        const cnt = Number(r.cnt ?? 0);
        moodCounts[key] = (moodCounts[key] || 0) + cnt;
        moodTotal += cnt;
      }
    } catch (e) {
      console.warn('Failed to aggregate moods for dashboard:', e);
      moodCounts = {};
      moodTotal = 0;
    }

    // =============================
    // ‚úÖ –ù–û–í–´–ô –ë–õ–û–ö: –ê–ì–†–ï–ì–ê–¶–ò–Ø –ò–ù–°–ê–ô–¢–û–í
    // =============================
let insightsDreamsCount = 0;
let insightsArtworksCount = 0;

try {
  const insightsSql = isAll
    ? `
      SELECT
        COUNT(DISTINCT CASE WHEN CAST(json_extract(meta, '$.insightLiked') AS REAL) = 1 THEN dream_id END) AS insights_dreams,
        COUNT(CASE WHEN CAST(json_extract(meta, '$.insightArtworksLiked') AS REAL) = 1 THEN 1 END) AS insights_artworks
      FROM messages
      WHERE user = ?
    `
    : `
      SELECT
        COUNT(DISTINCT CASE WHEN CAST(json_extract(meta, '$.insightLiked') AS REAL) = 1 THEN dream_id END) AS insights_dreams,
        COUNT(CASE WHEN CAST(json_extract(meta, '$.insightArtworksLiked') AS REAL) = 1 THEN 1 END) AS insights_artworks
      FROM messages
      WHERE user = ? AND created_at >= ?
    `;

  const insightsStmt = isAll
    ? d1.prepare(insightsSql).bind(userEmail)
    : d1.prepare(insightsSql).bind(userEmail, sinceTs);

  const insightsRes = await insightsStmt.first();
  insightsDreamsCount = Number(insightsRes?.insights_dreams ?? 0);
  insightsArtworksCount = Number(insightsRes?.insights_artworks ?? 0);

} catch (err) {
  console.error('Failed to aggregate insights:', err);
}

    
    // === DAILY CONVOS AGGREGATION FOR DASHBOARD ===
    let totalDailyConvos = 0;
    let dailyConvoInsightsCount = 0;
    try {
      const dailyCountRes = await d1.prepare(`SELECT COUNT(*) AS cnt FROM daily_convos WHERE user = ?`).bind(userEmail).first();
      totalDailyConvos = Number(dailyCountRes?.cnt ?? 0);

      // Count insights from messages linked to daily_convos (dream_id used)
      const dailyInsightsRes = await d1.prepare(`
        SELECT
          COUNT(DISTINCT CASE WHEN CAST(json_extract(meta, '$.insightLiked') AS REAL) = 1 THEN dream_id END) AS daily_convos_with_insight,
          SUM(CASE WHEN CAST(json_extract(meta, '$.insightArtworksLiked') AS REAL) = 1 THEN 1 ELSE 0 END) AS daily_artwork_insight_msgs
        FROM messages
        WHERE user = ? AND dream_id IN (SELECT id FROM daily_convos WHERE user = ?)
      `).bind(userEmail, userEmail).first();

      dailyConvoInsightsCount = Number(dailyInsightsRes?.daily_convos_with_insight ?? 0);
    } catch (e) {
      console.warn('Failed to aggregate daily_convos metrics for dashboard:', e);
      totalDailyConvos = totalDailyConvos || 0;
      dailyConvoInsightsCount = dailyConvoInsightsCount || 0;
    }

    // =============================
    // 10) –§–û–†–ú–ò–†–û–í–ê–ù–ò–ï –û–¢–í–ï–¢–ê
    // =============================

    // ‚úÖ –ü–ï–†–ò–û–î–ù–´–ï –î–ê–ù–ù–´–ï (–¥–ª—è –≥—Ä–∞—Ñ–∏–∫–æ–≤, –∏—Å—Ç–æ—Ä–∏–∏, –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π)
    const dashboardDataPeriod = {
      totalDreams: totalDreamsInPeriod, // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–Ω–æ–≤ –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º –ø–µ—Ä–∏–æ–¥–µ
      totalDreamsInPeriod: totalDreamsInPeriod,
      breakdownCounts: breakdownCounts, // –∏–∑ –ø–µ—Ä–∏–æ–¥–∞
      breakdownPercent: breakdownPercent, // –∏–∑ –ø–µ—Ä–∏–æ–¥–∞
      streak: streak, // —Å—Ç—Ä–∏–∫ –≤—Å–µ–≥–¥–∞ –∑–∞ –≥–æ–¥
      insights: insightsDreamsCount, // –∏–∑ –ø–µ—Ä–∏–æ–¥–∞
      depthScore: 0,
    };
    dashboardDataPeriod.depthScore = calculateDepthScore(dashboardDataPeriod);

    // ‚úÖ –û–ë–©–ò–ï –î–ê–ù–ù–´–ï (–ó–ê –í–°–Å –í–†–ï–ú–Ø) ‚Äî –¥–ª—è Depth Score, —É—Ä–æ–≤–Ω—è, –±–µ–π–¥–∂–µ–π
    const dashboardDataTotal = {
      totalDreams: totalDreams, // –í–°–ï —Å–Ω—ã –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è
      totalDreamsInPeriod: totalDreams, // –≤–∞–∂–Ω–æ: –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –í–°–ï —Å–Ω—ã
      breakdownCounts: {
        interpreted: interpretedCount, // –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è
        summarized: summarizedForScoreResult?.count || 0,
        artworks: artworksCount, // –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è
        dialogs: dialogDreamsCount, // –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è
      },
      breakdownPercent: {
        interpreted: totalDreams > 0 ? Math.round((interpretedCount / totalDreams) * 100) : 0,
        summarized: totalDreams > 0 ? Math.round(((summarizedForScoreResult?.count || 0) / totalDreams) * 100) : 0,
        artworks: totalDreams > 0 ? Math.round((artworksCount / totalDreams) * 100) : 0,
        dialogs: totalDreams > 0 ? Math.round((dialogDreamsCount / totalDreams) * 100) : 0,
      },
      streak: streak,
      insights: insightsDreamsCount, // –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è (–∏–∑ all-time –∑–∞–ø—Ä–æ—Å–∞ –≤—ã—à–µ)
      depthScore: 0,
    };
    dashboardDataTotal.depthScore = calculateDepthScore(dashboardDataTotal);

    // ‚úÖ DEPTH SCORE –° DECAY (–≤—Å–µ–≥–¥–∞ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π, –Ω–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ñ–∏–ª—å—Ç—Ä–∞)
    const now = Date.now();
    const baseDepthScoreTotal = dashboardDataTotal.depthScore;

    // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ decay
    let storedScore = baseDepthScoreTotal;
    let lastAt = now;
    try {
      const row = await d1
        .prepare('SELECT depth_score_stored, last_depth_update_at FROM user_depth_state WHERE user_email = ?')
        .bind(userEmail)
        .first();
      if (row) {
        storedScore = Number(row.depth_score_stored);
        lastAt = Number(row.last_depth_update_at);
      }
    } catch (e) {
      console.warn('Failed to load depth state:', e);
    }

    function applyDepthDecay({ baseScore, storedScore, lastAt, now, halfLifeDays = 30 }) {
      const hlMs = halfLifeDays * 24 * 60 * 60 * 1000;
      const dt = Math.max(0, now - (lastAt || now));
      const k = hlMs > 0 ? Math.pow(0.5, dt / hlMs) : 0;
      const decayed = baseScore + (storedScore - baseScore) * k;
      return Math.max(baseScore, decayed);
    }

    const depthScoreTotal = Math.round(applyDepthDecay({
  baseScore: baseDepthScoreTotal,
  storedScore,
  lastAt,
  now,
  halfLifeDays: 30,
}));

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ decay (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å)
    try {
      await d1.prepare(`
        INSERT INTO user_depth_state (user_email, depth_score_stored, last_depth_update_at)
        VALUES (?, ?, ?)
        ON CONFLICT(user_email) DO UPDATE SET
          depth_score_stored = excluded.depth_score_stored,
          last_depth_update_at = excluded.last_depth_update_at
      `).bind(userEmail, depthScoreTotal, now).run();
    } catch (e) {
      console.warn('Failed to save depth state:', e);
    }

    // ‚úÖ –ì–ï–ô–ú–ò–§–ò–ö–ê–¶–ò–Ø (–≤—Å–µ–≥–¥–∞ –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è)
    const level = getLevel(depthScoreTotal);

// ‚úÖ –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–æ–≤—ã–π –ª–∏ —É—Ä–æ–≤–µ–Ω—å
const lastSeenLevelRow = await env.DB.prepare(
  'SELECT last_seen_level FROM user_depth_state WHERE user_email = ?'
)
  .bind(userEmail)
  .first();

const isNew = level.level > (lastSeenLevelRow?.last_seen_level || 0);

// –í–æ–∑–≤—Ä–∞—â–∞–µ–º —É—Ä–æ–≤–µ–Ω—å —Å —Ñ–ª–∞–≥–æ–º isNew
const levelWithNew = {
  ...level,
  isNew,
};
    const badgesInfo = await checkAndUnlockBadges(d1, userEmail, dashboardDataTotal);
    const recommendedGoal = getNextGoal(level, badgesInfo.unlocked, dashboardDataTotal);
    const advice = generateAdvice(level, recommendedGoal, dashboardDataTotal);

    let currentBadgeGoalId = null;
    try {
      const row = await d1
        .prepare('SELECT current_badge_goal_id FROM user_goal_settings WHERE user_email = ?')
        .bind(userEmail)
        .first();
      currentBadgeGoalId = row?.current_badge_goal_id ?? null;
    } catch (e) {
      currentBadgeGoalId = null;
    }

    const currentGoal = (currentBadgeGoalId && BADGES[currentBadgeGoalId])
      ? {
          badgeId: currentBadgeGoalId,
          name: BADGES[currentBadgeGoalId].name,
          emoji: BADGES[currentBadgeGoalId].emoji,
          description: BADGES[currentBadgeGoalId].description,
          progress: calculateBadgeProgress(currentBadgeGoalId, dashboardDataTotal),
          advice: generateAdvice(level, { badgeId: currentBadgeGoalId }, dashboardDataTotal),
        }
      : null;

    // ‚úÖ –§–ò–ù–ê–õ–¨–ù–´–ô PAYLOAD
    const payload = {
      period: rangeParam, // '7d' | '30d' | '60d' | '90d' | '365d' | 'all'

      // =============================
      // ALL-TIME –ú–ï–¢–†–ò–ö–ò (–Ω–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ñ–∏–ª—å—Ç—Ä–∞)
      // =============================
      totalDreams, // –≤—Å–µ–≥–¥–∞ –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è
      entriesCount: totalDreams,
      interpretedCount, // –≤—Å–µ–≥–¥–∞ –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è
      interpretedPercent: totalDreams > 0 ? Math.round((interpretedCount / totalDreams) * 100) : 0,
      artworksCount, // –≤—Å–µ–≥–¥–∞ –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è
      dialogDreamsCount, // –≤—Å–µ–≥–¥–∞ –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è
      streak, // –≤—Å–µ–≥–¥–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –≥–æ–¥
      monthlyBlocks, // –≤—Å–µ–≥–¥–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 30 –¥–Ω–µ–π

      // =============================
      // –ü–ï–†–ò–û–î–ù–´–ï –ú–ï–¢–†–ò–ö–ò (–∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ñ–∏–ª—å—Ç—Ä–∞)
      // =============================
      totalDreamsInPeriod, // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–Ω–æ–≤ –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º –ø–µ—Ä–∏–æ–¥–µ
      score: lastScore, // score –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏ –∑–∞ –ø–µ—Ä–∏–æ–¥
      scoreDelta,
      history: historyOut, // –∏—Å—Ç–æ—Ä–∏—è –∑–∞ –ø–µ—Ä–∏–æ–¥
      highestScore: highestPoint ? { score: highestPoint.score, date: highestPoint.date } : null,
      breakdownCounts, // –∑–∞ –ø–µ—Ä–∏–æ–¥
      breakdownPercent, // –∑–∞ –ø–µ—Ä–∏–æ–¥
      recentDreams, // –∑–∞ –ø–µ—Ä–∏–æ–¥
      moodCounts, // –∑–∞ –ø–µ—Ä–∏–æ–¥
      moodTotal, // –∑–∞ –ø–µ—Ä–∏–æ–¥
      insightsDreamsCount, // –∑–∞ –ø–µ—Ä–∏–æ–¥
      insightsArtworksCount, // –∑–∞ –ø–µ—Ä–∏–æ–¥
      totalDailyConvos, // –≤—Å–µ–≥–¥–∞ –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è (–∏–ª–∏ –º–æ–∂–Ω–æ —Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å)
      dailyConvoInsightsCount, // –≤—Å–µ–≥–¥–∞ –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è

      lastUpdated: new Date().toISOString(),

      // =============================
      // –ì–ï–ô–ú–ò–§–ò–ö–ê–¶–ò–Ø (–≤—Å–µ–≥–¥–∞ –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è)
      // =============================
      gamification: {
        depthScoreTotal, // ‚úÖ –í–°–ï–ì–î–ê –û–î–ò–ù–ê–ö–û–í–´–ô (–∑–∞ –≤—Å—ë –≤—Ä–µ–º—è —Å decay)
        engagementScorePeriod: dashboardDataPeriod.depthScore, // ‚úÖ –ú–ï–ù–Ø–ï–¢–°–Ø (–∑–∞ –ø–µ—Ä–∏–æ–¥)
        level: {
          name: level.name,
          emoji: level.emoji,
          color: level.color,
          min: level.min,
          max: level.max,
        },
        badges: {
          unlocked: badgesInfo.unlocked.map((id) => ({
            id,
            name: BADGES[id].name,
            emoji: BADGES[id].emoji,
            category: BADGES[id].category,
            description: BADGES[id].description,
            unlockedAt: badgesInfo.unlockedAtById?.get(id) ?? null,
          })),
          new: badgesInfo.new.map((id) => ({
            id,
            name: BADGES[id].name,
            emoji: BADGES[id].emoji,
            category: BADGES[id].category,
            description: BADGES[id].description,
            unlockedAt: badgesInfo.unlockedAtById?.get(id) ?? null,
          })),
          unseen: badgesInfo.unseen.map((id) => ({
            id,
            name: BADGES[id].name,
            emoji: BADGES[id].emoji,
            category: BADGES[id].category,
            description: BADGES[id].description,
            unlockedAt: badgesInfo.unlockedAtById?.get(id) ?? null,
          })),
          all: Object.entries(BADGES).map(([id, badge]) => {
            const unlocked = badgesInfo.unlocked.includes(id);
            return {
              id,
              name: badge.name,
              emoji: badge.emoji,
              category: badge.category,
              description: badge.description,
              unlocked,
              unlockedAt: unlocked ? badgesInfo.unlockedAtById?.get(id) ?? null : null,
            };
          }),
        },
        currentGoal,
        recommendedGoal: recommendedGoal
          ? {
              badgeId: recommendedGoal.badgeId,
              name: recommendedGoal.name,
              emoji: recommendedGoal.emoji,
              description: recommendedGoal.description,
              progress: recommendedGoal.progress,
              advice,
            }
          : null,
      },
    };

    return new Response(JSON.stringify(payload), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });

  } catch (e) {
    console.error('Dashboard error:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// =============================
// ‚úÖ –û–¢–ú–ï–¢–ò–¢–¨ –ë–ï–ô–î–ñ–ò –ö–ê–ö –ü–†–û–°–ú–û–¢–†–ï–ù–ù–´–ï
// =============================

if (url.pathname === '/mark-badges-seen' && request.method === 'POST') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  try {
    const body = await request.json();
    const badgeIds = body.badgeIds || [];

    if (badgeIds.length === 0) {
      return new Response(JSON.stringify({ success: true }), {
        status: 200,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      });
    }

    const now = Date.now();

    const d1 = env.DB;

    for (const badgeId of badgeIds) {
      await d1
        .prepare('UPDATE user_badges SET seen_at = ? WHERE user_email = ? AND badge_id = ?')
        .bind(now, userEmail, badgeId)
        .run();
    }

    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  } catch (e) {
    console.error('Failed to mark badges as seen:', e);
    return new Response(JSON.stringify({ error: 'internal_error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }
}

if (url.pathname === '/api/gamification/mark-level-seen' && request.method === 'POST') {
  try {
    const authHeader = request.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return new Response(JSON.stringify({ error: 'unauthorized' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }

    const token = authHeader.substring(7);
    const payload = await verifyToken(token, JWT_SECRET);
    const userEmail = payload.email;

    const body = await request.json();
    const { level } = body;

    await env.DB.prepare(
      'UPDATE user_depth_state SET last_seen_level = ? WHERE user_email = ?'
    )
      .bind(level, userEmail)
      .run();

    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });

  } catch (err) {
    console.error('Error in /api/gamification/mark-level-seen:', err);
    return new Response(JSON.stringify({ 
      error: 'internal_error',
      message: err.message 
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
}

// --- PUT /me (–∑–∞–º–µ–Ω–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –±–ª–æ–∫) ---
if ((url.pathname === '/me' || url.pathname === '/api/me') && request.method === 'PUT') {
  const userEmail = await getUserEmail(request);
  if (!userEmail) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  const ct = request.headers.get('content-type') || '';
  if (!ct.includes('application/json')) {
    return new Response(JSON.stringify({ error: 'Invalid content type', message: 'application/json expected' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  let body;
  try {
    body = await request.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  let { name, avatar_icon, avatar_image_url } = body;

  if (name === undefined && avatar_icon === undefined && avatar_image_url === undefined) {
    return new Response(JSON.stringify({ error: 'At least one field (name, avatar_icon or avatar_image_url) is required' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  if (typeof name !== 'undefined' && (typeof name !== 'string' || name.length > 100)) {
    return new Response(JSON.stringify({ error: 'Invalid name (must be string up to 100 chars)' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  if (typeof avatar_icon !== 'undefined' && (typeof avatar_icon !== 'string' || !VALID_AVATAR_ICONS.includes(avatar_icon))) {
    return new Response(JSON.stringify({ error: 'Invalid avatar_icon' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  if (typeof avatar_image_url !== 'undefined' && (typeof avatar_image_url !== 'string' || !(avatar_image_url.startsWith('http://') || avatar_image_url.startsWith('https://')))) {
    return new Response(JSON.stringify({ error: 'Invalid avatar_image_url' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }

  try {
    // –°—Ñ–æ—Ä–º–∏—Ä—É–µ–º UPDATE-—á–∞—Å—Ç—å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
    const sets = [];
    const binds = [];

    if (typeof name !== 'undefined') { sets.push('name = ?'); binds.push(name); }
    if (typeof avatar_icon !== 'undefined') { sets.push('avatar_icon = ?'); binds.push(avatar_icon); }
    if (typeof avatar_image_url !== 'undefined') { sets.push('avatar_image_url = ?'); binds.push(avatar_image_url); }

    if (sets.length === 0) {
      return new Response(JSON.stringify({ error: 'Nothing to update' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      });
    }

    binds.push(userEmail);
    const sql = `UPDATE users SET ${sets.join(', ')} WHERE email = ?`;
    const res = await env.DB.prepare(sql).bind(...binds).run();

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –ª–∏ –∑–∞–ø–∏—Å—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç —Ç–µ–ø–µ—Ä—å –≤ —Ç–∞–±–ª–∏—Ü–µ
    let userRow = await env.DB.prepare('SELECT id FROM users WHERE email = ?').bind(userEmail).first();

    if (!userRow) {
      // –ï—Å–ª–∏ —Å—Ç—Ä–æ–∫–∏ –Ω–µ—Ç ‚Äî —Å–æ–∑–¥–∞—ë–º –µ—ë, –ø–æ–¥—Å—Ç–∞–≤–ª—è—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –∏–∑ KV
      const kvRaw = await env.USERS_KV.get(`user:${userEmail}`);
      let kv = {};
      try { kv = kvRaw ? JSON.parse(kvRaw) : {}; } catch (e) { kv = {}; }

      const password_hash = kv.password ?? ''; // –≤ –≤–∞—à–µ–º KV –ø–∞—Ä–æ–ª—å —Ö—Ä–∞–Ω–∏—Ç—Å—è –ø–æ–¥ –∫–ª—é—á–æ–º 'password'
      const id = kv.id ?? (typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : `id-${Date.now()}`);
      const created_at = kv.created ? new Date(kv.created).toISOString() : new Date().toISOString();

      // –í—ã–ø–æ–ª–Ω—è–µ–º INSERT (–≤–∫–ª—é—á–∞–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è id, email, password_hash)
      await env.DB.prepare(
        `INSERT INTO users (id, email, password_hash, name, avatar_icon, avatar_image_url, created_at)
         VALUES (?, ?, ?, ?, ?, ?, ?)`
      ).bind(id, userEmail, password_hash, name ?? null, avatar_icon ?? null, avatar_image_url ?? null, created_at).run();

      // –¢–µ–ø–µ—Ä—å –ø–æ–¥—Ç—è–Ω–µ–º —Å—Ç—Ä–æ–∫—É
      userRow = await env.DB.prepare('SELECT id FROM users WHERE email = ?').bind(userEmail).first();

      if (!userRow) {
        return new Response(JSON.stringify({ error: 'User not found or insert failed' }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders },
        });
      }
    }

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—É—é –∑–∞–ø–∏—Å—å
    const userFull = await env.DB.prepare(
      'SELECT id, email, name, avatar_icon, avatar_image_url, created_at FROM users WHERE email = ?'
    ).bind(userEmail).first();

    return new Response(JSON.stringify({ ok: true, user: userFull }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });

  } catch (e) {
    console.error('PUT /me error:', e);
    return new Response(JSON.stringify({ error: 'internal_error', message: e?.message || String(e) }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }
}

if (url.pathname === '/set-current-goal' && request.method === 'POST') {
  try {
    const userEmail = await getUserEmail(request);
    if (!userEmail) {
      return new Response(JSON.stringify({ error: 'unauthorized' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      });
    }

    let body = {};
    try { body = await request.json(); } catch {}

    const badgeId = body?.badgeId;

    // ‚úÖ –†–∞–∑—Ä–µ—à–∞–µ–º null –¥–ª—è —Å–Ω—è—Ç–∏—è —Ü–µ–ª–∏
    if (badgeId !== null && (!badgeId || typeof badgeId !== 'string')) {
      return new Response(JSON.stringify({ error: 'badgeId must be string or null' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      });
    }

    // ‚úÖ –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –±–µ–π–¥–∂–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ badgeId –Ω–µ null
    if (badgeId !== null && !BADGES[badgeId]) {
      return new Response(JSON.stringify({ error: 'unknown_badge' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json', ...corsHeaders },
      });
    }

    const now = Date.now();

    // ‚úÖ –î–û–ë–ê–í–¨ –õ–û–ì–ò–†–û–í–ê–ù–ò–ï
    console.log('üéØ Setting current goal:', { userEmail, badgeId, now });

    await env.DB.prepare(`
      INSERT INTO user_goal_settings (user_email, current_badge_goal_id, updated_at)
      VALUES (?, ?, ?)
      ON CONFLICT(user_email) DO UPDATE SET
        current_badge_goal_id = excluded.current_badge_goal_id,
        updated_at = excluded.updated_at
    `).bind(userEmail, badgeId, now).run();

    console.log('‚úÖ Current goal updated successfully');

    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  } catch (e) {
    console.error('‚ùå POST /set-current-goal error:', e);
    
    // ‚úÖ –í–ê–ñ–ù–û: –í–æ–∑–≤—Ä–∞—â–∞–µ–º CORS –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ!
    return new Response(JSON.stringify({ 
      error: 'internal_error', 
      message: e?.message || String(e),
      stack: e?.stack // ‚úÖ –¥–æ–±–∞–≤—å stack trace –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json', ...corsHeaders },
    });
  }
}

    return new Response(JSON.stringify({ error: 'Not found' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json', ...corsHeaders }
    });
  }
};